{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Java Object-Oriented Programming Course","text":"<p>Learn modern Java OOP by building. Clear concepts, practical examples, and projects that develop real programming skills.</p>"},{"location":"#who-its-for","title":"Who it's for","text":"<ul> <li>Students (at University Metropolitan Tirana) learning object-oriented programming concepts.</li> <li>Developers comfortable with basic programming who want to master Java OOP.</li> <li>Anyone seeking a structured approach to Java without unnecessary complexity.</li> </ul>"},{"location":"#whats-inside","title":"What's inside","text":"<p>Foundations: Build your OOP foundation with classes, objects, collections, and object-oriented thinking.</p> <p>Core OOP Principles: Master inheritance, polymorphism, encapsulation, and abstract programming.</p> <p>File and Exception Handling: Write robust applications that handle errors and work with external data.</p> <p>Modern Java: Use generics, lambdas, streams, and JavaFX for contemporary Java development.</p> <p>Projects: Apply your knowledge through progressive sprints and a capstone project.</p> <p>Resources: Reference materials, tools, and extended learning resources.</p>"},{"location":"#suggested-path","title":"Suggested path","text":"<ul> <li>Foundations first: Introduction to OOP \u2192 Classes &amp; Objects \u2192 Arrays &amp; Collections \u2192 Thinking in Objects.</li> <li>Core principles: Inheritance \u2192 Polymorphism \u2192 Encapsulation \u2192 Abstract Classes &amp; Interfaces.</li> <li>Practical skills: Exception Handling \u2192 Files &amp; Streams.</li> <li>Modern features: Generics \u2192 Lambdas &amp; Streams \u2192 JavaFX &amp; GUI.</li> <li>Build projects throughout to reinforce learning.</li> </ul>"},{"location":"#study-tips","title":"Study tips","text":"<ul> <li>Code every example yourself - reading code is not the same as writing it.</li> <li>Complete the exercises in each section before moving forward.</li> <li>Start each project sprint when you finish the related concepts.</li> <li>Explain concepts to others - teaching reveals what you truly understand.</li> </ul>"},{"location":"#word-of-encouragement","title":"Word of encouragement","text":"<p>Object-oriented programming changes how you think about code. Start simple, practice consistently, and build real projects.</p> <p>When concepts feel abstract, write more code. When projects feel overwhelming, return to the fundamentals and take smaller steps.</p> <p>Every expert was once a beginner. Keep coding, keep building, keep learning.</p>"},{"location":"00-tools/","title":"IDEs for This Course","text":"<p>A good IDE makes Java work smoother. The course recommends Eclipse, but IntelliJ IDEA, NetBeans, and VS Code are also fine. Pick what feels comfortable and runs well on your computer.</p> <p></p>"},{"location":"00-tools/#your-options","title":"Your options","text":"<ul> <li>Eclipse (recommended): Free, reliable, and well-suited for learning. Strong Java support, debugging, and project tools.</li> <li>IntelliJ IDEA: Polished experience and powerful features. Community Edition is free; Ultimate is paid.</li> <li>NetBeans: Simple to set up with solid Java and Maven support out of the box.</li> <li>VS Code: Lightweight editor that becomes a Java IDE with the Java Extension Pack.</li> </ul>"},{"location":"00-tools/#why-we-recommend-eclipse","title":"Why we recommend Eclipse","text":"<p>Eclipse gives a common setup for everyone, is easy to work with, and is fully capable for the course. It works well on Windows, macOS, and Linux, and has everything needed for projects, debugging, and refactoring.</p>"},{"location":"00-tools/#can-i-use-something-else","title":"Can I use something else?","text":"<p>Yes. All course materials and projects work in any of the IDEs above. If unsure, start with Eclipse. Switching later is easy once the basics are in place.</p>"},{"location":"00-tools/#next-steps","title":"Next steps","text":"<ul> <li>New to Java tools? Install Eclipse first and run a short <code>Hello, World</code> to confirm your setup.</li> <li>Comfortable with another IDE? Use it. Just make sure a recent JDK (e.g., Java 21) is installed and selected in the IDE settings.</li> </ul>"},{"location":"00-tools/eclipse-setup/","title":"Eclipse IDE Setup on Windows","text":"<p>This tutorial shows how to install and set up Eclipse for Java development on Windows. It also explains how to check or set the JDK inside Eclipse and run a quick test project. Estimated time: 20\u201330 minutes.</p>"},{"location":"00-tools/eclipse-setup/#why-this-matters","title":"Why this matters","text":"<ul> <li>Problem: Java work is slower without a stable IDE and a correct JDK setup. Installing tools wrong leads to errors and lost time.</li> <li>Practical benefits: Eclipse gives project templates, code completion, refactoring, and a good debugger, so learning and building Java apps is faster.</li> <li>Professional context: Eclipse is widely used in classrooms and industry, and supports current Java releases. Knowing it is useful for internships and jobs.</li> </ul>"},{"location":"00-tools/eclipse-setup/#prerequisites-and-goals","title":"Prerequisites and goals","text":"<ul> <li>Required: Windows 10 or 11 and a few GB of disk space.</li> <li>Nice to have: A recent JDK (Java 21+). If not installed, Eclipse can still run if bundled with a JRE, but a proper JDK is recommended.</li> <li>You will learn: Download and install Eclipse, set the JDK in Eclipse, and create and run a simple Java project.</li> </ul>"},{"location":"00-tools/eclipse-setup/#high-level-plan","title":"High-level plan","text":"<p>Download Eclipse, install it, confirm Java, set the JDK if needed, then build and run a <code>Hello, World</code> project to verify everything.</p>"},{"location":"00-tools/eclipse-setup/#step-by-step","title":"Step-by-step","text":""},{"location":"00-tools/eclipse-setup/#step-1-download-eclipse","title":"Step 1 \u2014 Download Eclipse","text":"<ul> <li>Go to the official Eclipse downloads page and get the Eclipse Installer for Windows (x86_64). Save the <code>.exe</code> file.</li> </ul>"},{"location":"00-tools/eclipse-setup/#step-2-run-the-installer","title":"Step 2 \u2014 Run the installer","text":"<ul> <li>Open the downloaded <code>.exe</code>. Choose <code>Eclipse IDE for Java Developers.</code></li> <li>Keep the default install folder unless a different location is required. Accept the license and click <code>Install</code></li> <li>When finished, click <code>Launch</code> to start Eclipse.</li> </ul>"},{"location":"00-tools/eclipse-setup/#step-3-choose-a-workspace","title":"Step 3 \u2014 Choose a workspace","text":"<ul> <li>On first launch, pick a workspace folder where projects will be saved (for example, <code>C:\\Users\\YourName\\EclipseWorkspace</code>). Check <code>Use this as default</code> to skip this prompt next time.</li> </ul>"},{"location":"00-tools/eclipse-setup/#step-4-check-or-set-the-jdk-in-eclipse","title":"Step 4 \u2014 Check or set the JDK in Eclipse","text":"<ul> <li>Check the detected Java: <code>Window \u2192 Preferences \u2192 Java \u2192 Installed JREs</code>. If a JDK is listed and checked, you are set.</li> <li>If empty or only a JRE is listed:<ul> <li>Install a JDK (for example, Java 21 or newer) using Oracle or another trusted vendor.</li> <li>In Eclipse: <code>Window \u2192 Preferences \u2192 Java \u2192 Installed JREs \u2192 Add \u2192 Standard VM \u2192 Next</code>. Point JRE home to the JDK folder (e.g., <code>C:\\Program Files\\Java\\jdk-21</code>). Select it as default.</li> </ul> </li> <li>Why this matters: A JDK includes the compiler and tools needed for Java development; a JRE alone is not enough.</li> </ul>"},{"location":"00-tools/eclipse-setup/#step-5-create-and-run-a-test-project","title":"Step 5 \u2014 Create and run a test project","text":"<ul> <li>Create project: <code>File \u2192 New \u2192 Java Project \u2192 Name: HelloWorld \u2192 Finish</code>.</li> <li>Create class: <code>Right-click src \u2192 New \u2192 Class \u2192 Name: Main \u2192 Finish.</code></li> <li>Paste and run: <pre><code>public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, Eclipse!\");\n    }\n}\n</code></pre></li> <li>Click the <code>Run</code> button (green triangle) or press <code>Ctrl+F11</code>. The Console should show: <code>Hello, Eclipse!</code></li> </ul>"},{"location":"00-tools/eclipse-setup/#common-issues-and-quick-fixes","title":"Common issues and quick fixes","text":"<ul> <li>Eclipse won\u2019t start: Make sure you downloaded the 64\u2011bit installer for 64\u2011bit Windows. Re-download if the file was corrupted.</li> <li><code>No Java virtual machine</code> message: Install a JDK and set it in Installed JREs as shown above.</li> <li>Wrong Java version used by a project: <code>Right\u2011click project \u2192 Properties \u2192 Java Build Path \u2192 Libraries</code>; or Java Compiler to select the correct level.</li> </ul>"},{"location":"00-tools/eclipse-setup/#next-steps","title":"Next steps","text":"<ul> <li>Learn shortcuts: <code>Rename (Alt+Shift+R)</code>, <code>Open Type (Ctrl+Shift+T)</code>, <code>Search (Ctrl+H)</code>.</li> <li>Turn on line numbers: <code>Window \u2192 Preferences \u2192 General \u2192 Editors \u2192 Text Editors \u2192 Show line numbers</code>.</li> <li>Connect Git: <code>Window \u2192 Perspective \u2192 Open Perspective \u2192 Git</code>; then clone the course repository.</li> </ul> <p>With Eclipse installed and a test project running, the environment is ready for the course work. Keep the setup simple, and move on to coding.</p>"},{"location":"01-fundamentals/","title":"Foundations Overview","text":"<p>Build the core concepts that power object-oriented programming. Clear explanations, practical examples, and exercises that establish the foundation for everything that follows</p> <p></p>"},{"location":"01-fundamentals/#introduction-to-oop","title":"Introduction to OOP","text":"<p>From procedures to objects</p> <p>Understand why object-oriented programming dictates how we structure code. Learn the fundamental shift from writing step-by-step procedures to modeling real-world entities as objects with properties and behaviors.</p> <p>You'll learn: Why OOP matters, the core principles that guide object design, and how to think in terms of objects rather than functions</p>"},{"location":"01-fundamentals/#classes-objects","title":"Classes &amp; Objects","text":"<p>Blueprints and instances</p> <p>Master the building blocks of Java OOP. Create your first classes, instantiate objects, define constructors, and understand how objects interact through methods and fields.</p> <p>You'll learn: How to design classes, create objects, write constructors and methods, and manage object state</p>"},{"location":"01-fundamentals/#arrays-collections","title":"Arrays &amp; Collections","text":"<p>Managing groups of data</p> <p>Work with collections of objects using arrays and ArrayList. Learn when to use each approach and how to store, access, and manipulate groups of related data efficiently.</p> <p>You'll learn: Array fundamentals, ArrayList operations, choosing the right collection type, and iterating through data</p>"},{"location":"01-fundamentals/#thinking-in-objects","title":"Thinking in Objects","text":"<p>The object-oriented mindset</p> <p>Develop the problem-solving approach that distinguishes object-oriented design. Learn to identify objects in real-world problems, define their responsibilities, and model relationships between them.</p> <p>You'll learn: How to decompose problems into objects, assign responsibilities, and design clean object interactions</p> <p>Start here: Begin with Introduction to OOP, then work through each topic in order. Complete the exercises after each section to reinforce your understanding\u2014practice builds intuition.</p>"},{"location":"01-fundamentals/arrays-lists/","title":"Collections and Class Relationships","text":""},{"location":"01-fundamentals/arrays-lists/#introduction-why-evolve-what-works","title":"Introduction - Why Evolve What Works","text":"<p>Last week you built a minimal working version of a banking system with <code>Customer</code> and <code>Account</code> classes. The foundation was solid: encapsulated fields, validated constructors, and methods that protected sensitive data. But real banking systems have additional requirements that expose limitations in the initial design.</p> <p>Consider what happens when a customer opens multiple accounts over time. Your current system can create individual <code>Account</code> objects, but there's no natural way for a <code>Customer</code> to manage their collection of accounts. You need methods to add new accounts, close old ones, search by account number, and calculate total holdings across all accounts. Arrays would require knowing the maximum number of accounts in advance and manual resizing logic.</p> <p>This tutorial refines your banking system to handle more complexity. You'll upgrade the <code>Account</code> class to use <code>static</code> fields properly for class-level identity management, and transform the <code>Customer</code> class to manage multiple accounts using ArrayList\u2014Java's dynamic, resizable collection.</p> <p>The starting code is available at: github.com/evisp/java-oop-course/week2_classes_objects</p> <p>By the end, you'll understand when static belongs at the class level rather than the object level, how to manage object collections idiomatically with <code>ArrayList</code>, and how to design methods that separate concerns cleanly\u2014preparing you for the next step of adding transaction history and deeper object relationships.</p> <p></p>"},{"location":"01-fundamentals/arrays-lists/#upgrading-the-account-class","title":"Upgrading the Account Class","text":"<p>The original <code>Account</code> class handled balance and basic transactions, but lacked two critical features: unique identification and the ability to freeze accounts for security. Real banks need both\u2014every account must have a permanent ID, and suspicious activity requires the ability to freeze accounts temporarily.</p>"},{"location":"01-fundamentals/arrays-lists/#adding-account-identity-with-static-fields","title":"Adding Account Identity with Static Fields","text":"<p>Every bank account needs a unique identifier that never changes. You could manually assign IDs when creating accounts, but that's error-prone and tedious. Instead, we'll use a static field to automatically generate unique IDs.</p>"},{"location":"01-fundamentals/arrays-lists/#understanding-static-class-level-vs-object-level-data","title":"Understanding Static: Class-Level vs Object-Level Data","text":"<p>Until now, every field you've seen belongs to individual objects. When you create three <code>Account</code> objects, each has its own <code>balance</code> field storing different values. This is instance-level data\u2014each object instance maintains its own copy.</p> <p>But some data doesn't belong to any single object; it belongs to the entire class. Think of it like this: if each account is a bank customer, the counter that assigns new customer numbers belongs to the bank itself, not to any individual customer.</p> <p>Here's the key distinction:</p> <pre><code>public class Account {\n    private double balance;          // Instance field: each account has its own balance\n    private static int accountCounter = 1000;  // Static field: shared by ALL accounts\n}\n</code></pre> <p>The <code>static</code> keyword means this field exists at the class level. There's only one <code>accountCounter</code> shared across all <code>Account</code> objects. When any account increments it, all future accounts see the new value.</p>"},{"location":"01-fundamentals/arrays-lists/#why-static-matters-for-id-generation","title":"Why Static Matters for ID Generation","text":"<p>Static fields are perfect for ID generation because you need exactly one counter shared across all accounts:</p> <pre><code>public class Account {\n    /** Static counter for generating unique account IDs */\n    private static int accountCounter = 1000;\n\n    /** Unique identifier for this account */\n    private int accountId;\n\n    /** Current balance in the account */\n    private double balance;\n</code></pre> <p>Notice the pattern: <code>accountCounter</code> is static (class-level, shared), while <code>accountId</code> is instance-level (each account has its own ID). The counter generates IDs; each account stores the ID it received.</p>"},{"location":"01-fundamentals/arrays-lists/#generating-ids-in-the-constructor","title":"Generating IDs in the Constructor","text":"<p>The constructor is the perfect place to assign IDs because every account must get one at birth:</p> <pre><code>/**\n * Constructs a new Account with zero balance and active status.\n * Automatically assigns a unique account ID.\n */\npublic Account() {\n    this.accountId = ++accountCounter;  // Increment counter, then assign\n    this.balance   = 0.0;\n}\n\n/**\n * Constructs a new Account with the specified initial balance and active status.\n * Automatically assigns a unique account ID.\n * \n * @param initialBalance the starting balance for the account (must be non-negative)\n */\npublic Account(double initialBalance) {\n    if (initialBalance &lt; 0) {\n        System.out.println(\"Initial balance cannot be negative. Provided: \u20ac\" + initialBalance);\n    }\n    this.accountId = ++accountCounter;  // Same ID generation logic\n    this.balance   = initialBalance;\n}\n</code></pre> <p>The expression <code>++accountCounter</code> is crucial: it increments the static counter first, then returns the new value. This ensures each account gets a unique, sequential ID starting from 1001, 1002, 1003, and so on.</p>"},{"location":"01-fundamentals/arrays-lists/#accessing-static-vs-instance-fields","title":"Accessing Static vs Instance Fields","text":"<p>This is where many programmers make mistakes. Static fields belong to the class, not to objects:</p> <pre><code>// WRONG: accessing static field through an object\nAccount acc = new Account();\nint counter = acc.accountCounter;  // Bad style - static accessed through instance\n\n// CORRECT: accessing static field through the class\nint counter = Account.accountCounter;  // Good - but only if accountCounter were public\n</code></pre> <p>Since <code>accountCounter</code> is private, external code can't access it directly. If you needed to expose it (for reporting, for example), you'd add a static getter:</p> <pre><code>/**\n * Returns the current account counter value.\n * \n * @return the next account ID that will be assigned\n */\npublic static int getAccountCounter() {\n    return accountCounter;\n}\n</code></pre> <p>Notice the getter is also <code>static</code>\u2014it accesses static data, so it must be a static method.</p>"},{"location":"01-fundamentals/arrays-lists/#adding-the-account-id-getter","title":"Adding the Account ID Getter","text":"<p>Each account needs to expose its own ID through a regular (non-static) getter:</p> <pre><code>/**\n * Returns the unique account ID.\n * \n * @return the account ID\n */\npublic int getAccountId() {\n    return accountId;\n}\n</code></pre> <p>This is an instance method because it returns data specific to each account object.</p>"},{"location":"01-fundamentals/arrays-lists/#adding-account-freeze-capability","title":"Adding Account Freeze Capability","text":"<p>Banks need the ability to freeze accounts when fraud is suspected or legal issues arise. A frozen account should reject all transactions until unfrozen.</p>"},{"location":"01-fundamentals/arrays-lists/#the-isfrozen-field","title":"The isFrozen Field","text":"<p>Add a new instance field to track freeze status:</p> <pre><code>public class Account {\n    private static int accountCounter = 1000;\n    private int accountId;\n    private double balance;\n\n    /** Status of the account (active or frozen) */\n    private boolean isFrozen;\n}\n</code></pre> <p>Every account starts unfrozen, so initialize it in both constructors:</p> <pre><code>public Account() {\n    this.accountId = ++accountCounter;\n    this.balance   = 0.0;\n    this.isFrozen  = false;  // New accounts are active\n}\n\npublic Account(double initialBalance) {\n    if (initialBalance &lt; 0) {\n        System.out.println(\"Initial balance cannot be negative. Provided: \u20ac\" + initialBalance);\n    }\n    this.accountId = ++accountCounter;\n    this.balance   = initialBalance;\n    this.isFrozen  = false;  // New accounts are active\n}\n</code></pre>"},{"location":"01-fundamentals/arrays-lists/#freeze-and-unfreeze-methods","title":"Freeze and Unfreeze Methods","text":"<p>Add methods to control the freeze state:</p> <pre><code>/**\n * Checks if the account is frozen.\n * \n * @return true if account is frozen, false otherwise\n */\npublic boolean isFrozen() {\n    return isFrozen;\n}\n\n/**\n * Freezes the account, preventing withdrawals and deposits.\n */\npublic void freezeAccount() {\n    this.isFrozen = true;\n    System.out.println(\"Account #\" + accountId + \" has been frozen.\");\n}\n\n/**\n * Unfreezes the account, allowing normal operations.\n */\npublic void unfreezeAccount() {\n    this.isFrozen = false;\n    System.out.println(\"Account #\" + accountId + \" has been unfrozen.\");\n}\n</code></pre> <p>Notice how the freeze methods reference <code>accountId</code> in their messages\u2014this is why having unique IDs matters for logging and auditing.</p>"},{"location":"01-fundamentals/arrays-lists/#enforcing-freeze-in-transactions","title":"Enforcing Freeze in Transactions","text":"<p>Now update <code>deposit()</code> and <code>withdraw()</code> to check freeze status before processing:</p> <pre><code>/**\n * Deposits the specified amount into the account.\n * \n * @param amount the amount to deposit (must be positive)\n * @return true if deposit was successful, false otherwise\n */\npublic boolean deposit(double amount) {\n    if (isFrozen) {\n        System.out.println(\"Cannot deposit. Account #\" + accountId + \" is frozen.\");\n        return false;\n    }\n\n    if (amount &gt; 0) {\n        balance += amount;\n        System.out.println(\"Deposited: \u20ac\" + amount + \" to Account #\" + accountId);\n        return true;\n    } else {\n        System.out.println(\"Deposit amount must be positive.\");\n        return false;\n    }\n}\n\n/**\n * Withdraws the specified amount from the account.\n * \n * @param amount the amount to withdraw (must be positive and not exceed balance)\n * @return true if withdrawal was successful, false otherwise\n */\npublic boolean withdraw(double amount) {\n    if (isFrozen) {\n        System.out.println(\"Cannot withdraw. Account #\" + accountId + \" is frozen.\");\n        return false;\n    }\n\n    if (amount &lt;= 0) {\n        System.out.println(\"Withdrawal amount must be positive.\");\n        return false;\n    }\n\n    if (amount &gt; balance) {\n        System.out.println(\"Insufficient funds. Current balance: \u20ac\" + balance);\n        return false;\n    }\n\n    balance -= amount;\n    System.out.println(\"Withdrawn: \u20ac\" + amount + \" from Account #\" + accountId);\n    return true;\n}\n</code></pre> <p>The freeze check comes first in both methods, creating a security barrier that prevents any transaction on frozen accounts.</p>"},{"location":"01-fundamentals/arrays-lists/#updating-tostring-for-complete-information","title":"Updating toString for Complete Information","text":"<p>The <code>toString()</code> method should now show the ID and freeze status:</p> <pre><code>/**\n * Returns a string representation of the account.\n * \n * @return a formatted string showing the account details\n */\n@Override\npublic String toString() {\n    String status = isFrozen ? \"[FROZEN]\" : \"[ACTIVE]\";\n    return \"Account{\" +\n            \"id=\" + accountId +\n            \", balance=\u20ac\" + String.format(\"%.2f\", balance) +\n            \", status=\" + status +\n            '}';\n}\n</code></pre> <p>Now when you print an account, you see its complete state: ID, balance, and security status.</p>"},{"location":"01-fundamentals/arrays-lists/#testing-the-enhanced-account","title":"Testing the Enhanced Account","text":"<p>Here's how the new features work in practice:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Create accounts - IDs auto-generated\n        Account acc1 = new Account(500.0);\n        Account acc2 = new Account(1000.0);\n\n        System.out.println(acc1);  // Account{id=1001, balance=\u20ac500.00, status=[ACTIVE]}\n        System.out.println(acc2);  // Account{id=1002, balance=\u20ac1000.00, status=[ACTIVE]}\n\n        // Freeze an account\n        acc1.freezeAccount();  // Account #1001 has been frozen.\n\n        // Try transactions on frozen account\n        acc1.deposit(100.0);   // Cannot deposit. Account #1001 is frozen.\n        acc1.withdraw(50.0);   // Cannot withdraw. Account #1001 is frozen.\n\n        // Unfreeze and retry\n        acc1.unfreezeAccount(); // Account #1001 has been unfrozen.\n        acc1.deposit(100.0);    // Deposited: \u20ac100.0 to Account #1001\n\n        System.out.println(acc1);  // Account{id=1001, balance=\u20ac600.00, status=[ACTIVE]}\n    }\n}\n</code></pre>"},{"location":"01-fundamentals/arrays-lists/#why-this-design-works","title":"Why This Design Works","text":"<p>Static for shared identity: One counter ensures all accounts get unique, sequential IDs without manual coordination.</p> <p>Instance fields for object state: Each account maintains its own balance, ID, and freeze status independently.</p> <p>Security layering: Freeze checks at the method entry points create a single, consistent enforcement point.</p> <p>Clear representation: The <code>toString()</code> method shows all critical information at a glance for debugging and logging.</p> <p>The Account class now handles real banking requirements: automatic unique identification through static fields, and security controls through instance state. Next, you'll see how the Customer class uses collections to manage multiple accounts like these.</p>"},{"location":"01-fundamentals/arrays-lists/#building-customer-account-relationships-with-arraylist","title":"Building Customer-Account Relationships with ArrayList","text":"<p>The original <code>Customer</code> class stored personal information but had no way to manage accounts. In real banking, customers open multiple accounts over time: checking accounts, savings accounts, investment accounts. Your code needs to reflect this one-to-many relationship: one customer, many accounts.</p>"},{"location":"01-fundamentals/arrays-lists/#the-one-to-many-relationship-problem","title":"The One-to-Many Relationship Problem","text":"<p>Consider what you'd need without collections:</p> <pre><code>// Inflexible approach - what if customer needs more than 3 accounts?\nprivate Account account1;\nprivate Account account2;\nprivate Account account3;\n</code></pre> <p>This doesn't scale. You'd need separate fields for every possible account, manual null checks everywhere, and custom logic for searching. Arrays would be slightly better but still require knowing the maximum account count in advance and manually shifting elements when removing accounts.</p> <p>ArrayList solves this elegantly. It's a dynamic, resizable collection that grows and shrinks automatically. </p> <p>You add accounts as needed, remove them when closed, and search without worrying about array bounds or null slots.</p>"},{"location":"01-fundamentals/arrays-lists/#adding-the-arraylist-import-and-field","title":"Adding the ArrayList Import and Field","text":"<p>First, import ArrayList from the Java Collections Framework:</p> <pre><code>import java.util.ArrayList;\n</code></pre> <p>Then add the collection field to Customer:</p> <pre><code>public class Customer {\n    private int id;\n    private String name;\n    private int age;\n    private String address;\n\n    /** List of accounts owned by this customer */\n    private ArrayList&lt;Account&gt; accounts;\n}\n</code></pre> <p>The syntax <code>ArrayList&lt;Account&gt;</code> uses generics\u2014it tells Java this list will only hold <code>Account</code> objects. The compiler enforces this, preventing you from accidentally adding the wrong type of object.</p>"},{"location":"01-fundamentals/arrays-lists/#initializing-the-arraylist","title":"Initializing the ArrayList","text":"<p>Collections must be initialized before use. The constructor is the right place:</p> <pre><code>/**\n * Constructs a new Customer with the specified details.\n * Initializes an empty list of accounts.\n * \n * @param id the unique customer identifier\n * @param name the customer's full name\n * @param age the customer's age\n * @param address the customer's address\n */\npublic Customer(int id, String name, int age, String address) {\n    this.id       = id;\n    this.name     = name;\n    this.age      = age;\n    this.address  = address;\n    this.accounts = new ArrayList&lt;&gt;();  // Start with empty list\n}\n</code></pre> <p>The <code>new ArrayList&lt;&gt;()</code> creates an empty list ready to accept <code>Account</code> objects. The diamond operator <code>&lt;&gt;</code> lets Java infer the type from the field declaration, avoiding repetition.</p>"},{"location":"01-fundamentals/arrays-lists/#understanding-encapsulation-with-collections","title":"Understanding Encapsulation with Collections","text":"<p>Notice <code>accounts</code> is <code>private</code>. This is crucial, because external code shouldn't access the internal list directly. If you exposed it with a simple getter:</p> <pre><code>// DANGEROUS: don't do this\npublic ArrayList&lt;Account&gt; getAccounts() {\n    return accounts;  // Returns direct reference to internal list\n}\n</code></pre> <p>Any code could then add, remove, or modify accounts without going through your validation logic. Instead, you provide controlled methods that maintain the integrity of the relationship.</p>"},{"location":"01-fundamentals/arrays-lists/#adding-accounts-the-addaccount-method","title":"Adding Accounts: The addAccount Method","text":"<p>The first relationship method lets customers open new accounts:</p> <pre><code>/**\n * Adds a new account to this customer's account list.\n * \n * @param account the account to add\n * @return true if account was successfully added\n */\npublic boolean addAccount(Account account) {\n    if (account == null) {\n        System.out.println(\"Cannot add null account.\");\n        return false;\n    }\n    accounts.add(account);\n    System.out.println(\"Account #\" + account.getAccountId() + \" added to customer \" + name);\n    return true;\n}\n</code></pre> <p>This method demonstrates three key principles:</p> <ul> <li>Validation: Check for null before adding to prevent runtime errors later.</li> <li>Encapsulation: External code can't manipulate the list directly; it must go through this method.</li> <li>Feedback: Returns a boolean indicating success and prints a confirmation message.</li> </ul> <p>The <code>add()</code> method is provided by ArrayList and appends the new account to the end of the list. No manual array management required.</p>"},{"location":"01-fundamentals/arrays-lists/#removing-accounts-the-removeaccount-method","title":"Removing Accounts: The removeAccount Method","text":"<p>When customers close accounts, you need to remove them from the list:</p> <pre><code>/**\n * Removes an account from this customer's account list.\n * \n * @param account the account to remove\n * @return true if account was found and removed, false otherwise\n */\npublic boolean removeAccount(Account account) {\n    if (accounts.remove(account)) {\n        System.out.println(\"Account #\" + account.getAccountId() + \" removed from customer \" + name);\n        return true;\n    } else {\n        System.out.println(\"Account not found for customer \" + name);\n        return false;\n    }\n}\n</code></pre> <p>The ArrayList <code>remove()</code> method searches for the object and removes it if found, returning <code>true</code> on success and <code>false</code> if the object wasn't in the list. This handles the search and removal in one operation.</p>"},{"location":"01-fundamentals/arrays-lists/#searching-for-accounts-the-findaccount-method","title":"Searching for Accounts: The findAccount Method","text":"<p>Customers need to interact with specific accounts, so you need a search method:</p> <pre><code>/**\n * Searches for an account by its account ID.\n * \n * @param accountId the ID of the account to find\n * @return the Account if found, null otherwise\n */\npublic Account findAccount(int accountId) {\n    for (Account account : accounts) {\n        if (account.getAccountId() == accountId) {\n            return account;\n        }\n    }\n    return null;\n}\n</code></pre> <p>This uses the enhanced for-each loop, Java's clean syntax for iterating over collections:</p> <pre><code>for (Account account : accounts) {\n    // account is each element in the accounts list, one at a time\n}\n</code></pre> <p>Read this as \"for each account in accounts.\" It's much cleaner than traditional index-based loops and works with any collection type.</p> <p>The method performs a linear search: it checks each account until it finds a matching ID, then returns that account. If no match is found, it returns <code>null</code>.</p>"},{"location":"01-fundamentals/arrays-lists/#getting-the-account-count","title":"Getting the Account Count","text":"<p>A simple utility method to check how many accounts a customer has:</p> <pre><code>/**\n * Returns the total number of accounts owned by this customer.\n * \n * @return the number of accounts\n */\npublic int getAccountCount() {\n    return accounts.size();\n}\n</code></pre> <p>ArrayList's <code>size()</code> method returns the current number of elements\u2014no manual counting needed.</p>"},{"location":"01-fundamentals/arrays-lists/#connecting-customer-and-account-delegation-methods","title":"Connecting Customer and Account: Delegation Methods","text":"<p>Now comes the powerful part: customers can perform banking operations by delegating to their accounts. This demonstrates composition</p> <p>Customer doesn't duplicate Account's deposit/withdraw logic; it coordinates access to the right account.</p>"},{"location":"01-fundamentals/arrays-lists/#depositing-to-a-specific-account","title":"Depositing to a Specific Account","text":"<pre><code>/**\n * Deposits money into a specific account.\n * \n * @param accountId the ID of the account to deposit into\n * @param amount the amount to deposit\n * @return true if deposit was successful, false otherwise\n */\npublic boolean deposit(int accountId, double amount) {\n    Account account = findAccount(accountId);\n    if (account == null) {\n        System.out.println(\"Account #\" + accountId + \" not found for customer \" + name);\n        return false;\n    }\n    return account.deposit(amount);\n}\n</code></pre> <p>This method:</p> <ol> <li>Searches for the account using <code>findAccount()</code></li> <li>Validates that the account exists</li> <li>Delegates the actual deposit to the Account object</li> </ol> <p>The Customer class doesn't know or care about balance validation, freeze checks, or how deposits work\u2014that's Account's job. Customer just routes the operation to the right place.</p>"},{"location":"01-fundamentals/arrays-lists/#withdrawing-from-a-specific-account","title":"Withdrawing from a Specific Account","text":"<p>The withdrawal method follows the same pattern:</p> <pre><code>/**\n * Withdraws money from a specific account.\n * \n * @param accountId the ID of the account to withdraw from\n * @param amount the amount to withdraw\n * @return true if withdrawal was successful, false otherwise\n */\npublic boolean withdraw(int accountId, double amount) {\n    Account account = findAccount(accountId);\n    if (account == null) {\n        System.out.println(\"Account #\" + accountId + \" not found for customer \" + name);\n        return false;\n    }\n    return account.withdraw(amount);\n}\n</code></pre> <p>Again, Customer acts as a coordinator, not a controller. Each class maintains its own responsibilities: Customer manages the collection of accounts, while Account handles its own balance and validation rules.</p>"},{"location":"01-fundamentals/arrays-lists/#calculating-total-balance-across-all-accounts","title":"Calculating Total Balance Across All Accounts","text":"<p>Customers often want to see their total holdings across all accounts:</p> <pre><code>/**\n * Calculates the total balance across all accounts.\n * \n * @return the sum of all account balances\n */\npublic double getTotalBalance() {\n    double total = 0.0;\n    for (Account account : accounts) {\n        total += account.getBalance();\n    }\n    return total;\n}\n</code></pre> <p>This demonstrates aggregation, that is combining data from multiple related objects. The for-each loop iterates through all accounts, asking each for its balance and accumulating the sum.</p> <p>Notice that Customer doesn't access Account's private <code>balance</code> field directly (it can't\u2014it's private). Instead, it uses the public <code>getBalance()</code> getter. Encapsulation is maintained across the relationship.</p>"},{"location":"01-fundamentals/arrays-lists/#displaying-all-accounts","title":"Displaying All Accounts","text":"<p>A utility method to show a customer's complete account portfolio:</p> <pre><code>/**\n * Displays all accounts owned by this customer.\n */\npublic void displayAllAccounts() {\n    System.out.println(\"\\n--- Accounts for \" + name + \" ---\");\n    if (accounts.isEmpty()) {\n        System.out.println(\"No accounts found.\");\n    } else {\n        for (Account account : accounts) {\n            System.out.println(\"  \" + account);\n        }\n        System.out.println(\"Total Balance: \u20ac\" + String.format(\"%.2f\", getTotalBalance()));\n    }\n}\n</code></pre> <p>The <code>isEmpty()</code> method checks if the list has zero elements. If accounts exist, the loop prints each one (automatically calling Account's <code>toString()</code> method), then shows the total balance.</p>"},{"location":"01-fundamentals/arrays-lists/#updating-customers-tostring","title":"Updating Customer's toString","text":"<p>The Customer's string representation should now show account information:</p> <pre><code>/**\n * Returns a string representation of the customer.\n * \n * @return a formatted string containing customer details\n */\n@Override\npublic String toString() {\n    return \"Customer{\" +\n            \"id=\" + id +\n            \", name='\" + name + '\\'' +\n            \", age=\" + age +\n            \", address='\" + address + '\\'' +\n            \", accounts=\" + accounts.size() +\n            \", totalBalance=\u20ac\" + String.format(\"%.2f\", getTotalBalance()) +\n            '}';\n}\n</code></pre> <p>This provides a compact summary: how many accounts and the total balance across all of them.</p>"},{"location":"01-fundamentals/arrays-lists/#testing-the-complete-relationship","title":"Testing the Complete Relationship","text":"<p>Here's how Customer and Account work together:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Create a customer\n        Customer ada = new Customer(1815, \"Ada Lovelace\", 36, \"London, England\");\n\n        // Create and add accounts\n        Account checking = new Account(1000.0);\n        Account savings = new Account(5000.0);\n\n        ada.addAccount(checking);  // Account #1001 added to customer Ada Lovelace\n        ada.addAccount(savings);   // Account #1002 added to customer Ada Lovelace\n\n        System.out.println(ada);  // Shows 2 accounts, total \u20ac6000.00\n\n        // Deposit through Customer\n        ada.deposit(1001, 500.0);  // Deposited: \u20ac500.0 to Account #1001\n\n        // Withdraw through Customer\n        ada.withdraw(1002, 200.0); // Withdrawn: \u20ac200.0 from Account #1002\n\n        // Display complete account information\n        ada.displayAllAccounts();\n        // --- Accounts for Ada Lovelace ---\n        //   Account{id=1001, balance=\u20ac1500.00, status=[ACTIVE]}\n        //   Account{id=1002, balance=\u20ac4800.00, status=[ACTIVE]}\n        // Total Balance: \u20ac6300.00\n\n        // Find and freeze a specific account\n        Account found = ada.findAccount(1001);\n        if (found != null) {\n            found.freezeAccount();  // Account #1001 has been frozen.\n        }\n\n        // Try to deposit to frozen account\n        ada.deposit(1001, 100.0);  // Cannot deposit. Account #1001 is frozen.\n    }\n}\n</code></pre>"},{"location":"01-fundamentals/arrays-lists/#why-this-design-works_1","title":"Why This Design Works","text":"<ul> <li>Single Responsibility: Customer manages the account collection; Account manages its own money and state.</li> <li>Encapsulation: Private list with public methods prevents unauthorized manipulation.</li> <li>Delegation: Customer doesn't duplicate Account logic; it routes operations to the right account.</li> <li>Composition: The Customer-Account relationship reflects real-world banking naturally.</li> <li>Scalability: ArrayList grows dynamically as customers open more accounts without code changes.</li> </ul> <p>The Customer class has evolved from a simple data container into a sophisticated coordinator that manages a one-to-many relationship with accounts, all while maintaining clean separation of concerns and proper encapsulation.</p>"},{"location":"01-fundamentals/arrays-lists/#summary","title":"Summary","text":"<p>You've transformed a basic banking system into one that handles real-world complexity. The upgrades touched two critical areas: class-level identity management and dynamic object relationships.</p>"},{"location":"01-fundamentals/arrays-lists/#key-concepts-mastered","title":"Key Concepts Mastered","text":""},{"location":"01-fundamentals/arrays-lists/#static-fields-for-shared-data","title":"Static fields for shared data","text":"<p>The <code>accountCounter</code> generates unique IDs at the class level, demonstrating when data belongs to the class rather than individual objects. Static fields are shared across all instances, making them perfect for ID generation and shared configuration.</p>"},{"location":"01-fundamentals/arrays-lists/#arraylist-for-dynamic-relationships","title":"ArrayList for dynamic relationships","text":"<p>The <code>Customer</code> class now manages a growing collection of accounts using <code>ArrayList&lt;Account&gt;</code>, eliminating the rigid constraints of arrays. Collections grow and shrink as customers open and close accounts, reflecting real banking operations.</p>"},{"location":"01-fundamentals/arrays-lists/#one-to-many-relationships","title":"One-to-many relationships","text":"<p>Customer coordinates multiple accounts through encapsulated methods\u2014<code>addAccount()</code>, <code>removeAccount()</code>, <code>findAccount()</code>, and <code>getTotalBalance()</code>\u2014demonstrating how objects collaborate while maintaining clear responsibilities.</p>"},{"location":"01-fundamentals/arrays-lists/#delegation-over-duplication","title":"Delegation over duplication","text":"<p>Customer doesn't reimplement deposit and withdrawal logic; it delegates to Account objects. This separation of concerns keeps each class focused on its own responsibilities.</p>"},{"location":"01-fundamentals/arrays-lists/#enhanced-iteration-patterns","title":"Enhanced iteration patterns","text":"<p>The for-each loop provides clean, readable iteration over collections, making code easier to understand and maintain.</p>"},{"location":"01-fundamentals/arrays-lists/#complete-code","title":"Complete Code","text":"<p>Find the complete working code organized by version:</p> <ul> <li>v1_basic_classes - Starting point with simple Customer and Account</li> <li>v2_basic_collections - Enhanced version with static IDs, ArrayList, and relationships</li> </ul>"},{"location":"01-fundamentals/classes-objects/","title":"Classes & Objects","text":""},{"location":"01-fundamentals/classes-objects/#introduction-why-classes-matter","title":"Introduction - Why Classes Matter","text":"<p>Imagine you are tasked with building a digital banking system for a growing financial institution. The system needs to handle customers, their personal information, multiple account types, and secure financial transactions. Traditional programming approaches using separate variables and functions quickly become inefficient when dealing with complex, interconnected data like customer profiles linked to multiple accounts with different balances and transaction histories.</p> <p>Object-oriented programming provides an elegant solution by letting you model real-world entities directly in code. Instead of juggling separate arrays and variables, you create classes that represent actual things: a <code>Customer</code> class that knows its own name, ID, and contact information, and an <code>Account</code> class that manages its own balance and validates its own transactions.</p> <p>We will build a complete bank account management system step by step, starting with fundamental concepts and ending with a working application. Today, you'll create <code>Customer</code> and <code>Account</code> classes that interact naturally.</p> <p>Through this practical project, you will learn the core building blocks of object-oriented programming: how to define classes as blueprints for objects, use constructors to create properly initialized objects, implement encapsulation with getters and setters to protect sensitive data, and override the <code>toString()</code> method for clear object representation. </p> <p></p>"},{"location":"01-fundamentals/classes-objects/#the-blueprint-concept-understanding-classes","title":"The Blueprint Concept - Understanding Classes","text":"<p>Think of a class as an architect's blueprint for a house. The blueprint itself isn't a house you can live in\u2014it's a detailed plan that specifies where the rooms go, how big they should be, and what features each room should have. But from that single blueprint, a construction company can build dozens of identical houses, each one a real, physical structure where families can actually live.</p> <p>In programming, classes work exactly the same way. </p> <p>A class is a blueprint that defines what data an object should contain and what actions it can perform. </p> <p>The class itself doesn't hold any actual data\u2014it's just the template.</p> <p>Objects are the real instances built from that class blueprint, each containing actual values and able to perform real operations.</p> <p>Let's see this concept in action with our banking system. Here's our first empty <code>Customer</code> class\u2014our blueprint:</p> <pre><code>public class Customer {\n    // This is our blueprint - it defines the structure\n    // but doesn't contain any actual customer data yet\n}\n</code></pre> <p>This <code>Customer</code> class is like our architectural blueprint. It exists, but it doesn't represent any specific customer. To create actual customers (objects), we instantiate the class:</p> <pre><code>public class Main {\npublic static void main(String[] args) {\n    // Creating actual Customer objects from our blueprint\n    Customer customer1 = new Customer(); \n    Customer customer2 = new Customer(); \n    // customer1 and customer2 are separate objects (houses)\n    // built from the same Customer class (blueprint)\n}\n</code></pre> <p>Notice the key terminology here: <code>Customer</code> (with capital C) is the class - our blueprint. <code>customer1</code> and <code>customer2</code> are objects or instances - actual customers created from that blueprint. Each object exists independently and can hold different data, just like two houses built from the same blueprint can have different families living in them and different furniture inside.</p> <p>The power of this blueprint concept becomes clear when you realize that from one well-designed class, you can create hundreds or thousands of objects, each managing its own data safely and consistently.</p>"},{"location":"01-fundamentals/classes-objects/#building-our-first-class-customer","title":"Building Our First Class - Customer","text":""},{"location":"01-fundamentals/classes-objects/#class-definition-and-fields","title":"Class Definition and Fields","text":"<p>Now let's add substance to our blueprint. A real customer has essential information: their name, a unique ID, and an email address. But here's where object-oriented programming gets interesting\u2014we need to decide who can access this information and how.</p> <pre><code>public class Customer {\n    // Private fields - the customer's sensitive data\n    private int id;\n    private String name;\n    private int age;\n    private String address;\n    // This data is now protected inside the class\n}\n</code></pre> <p>Notice the <code>private</code> keyword before each field. This is encapsulation in action\u2014we're building walls around our data. Think of it like a bank vault: the money (data) is stored inside, but you can't just walk in and grab it. You need to go through proper channels (methods) to access or modify it.</p>"},{"location":"01-fundamentals/classes-objects/#private-vs-public-access-the-security-difference","title":"Private vs Public Access: The Security Difference","text":"<p>In banking, data protection isn't just good practice\u2014it's legally required. Imagine if anyone could directly change a customer's account balance or ID number:</p> <p>With <code>private</code> fields, this direct manipulation becomes impossible. The compiler will throw an error if external code tries to access private data directly. This forces all interactions to go through controlled methods that we design, where we can add validation, logging, and business logic.</p>"},{"location":"01-fundamentals/classes-objects/#why-encapsulation-matters-in-banking","title":"Why Encapsulation Matters in Banking","text":"<p>Banks handle sensitive financial data that requires multiple layers of protection. Encapsulation provides the first line of defense by ensuring that:</p> <ul> <li>Data Integrity: Customer IDs can't be accidentally set to invalid values</li> <li>Business Rules: Email addresses must follow proper formats  </li> <li>Audit Trails: All data changes go through trackable methods</li> <li>Security: Sensitive information is never exposed directly to external code</li> </ul> <p>When you encapsulate data properly, you create a controlled environment where every interaction with customer information goes through your carefully designed security checkpoints. </p>"},{"location":"01-fundamentals/classes-objects/#the-constructor-bringing-objects-to-life","title":"The Constructor - Bringing Objects to Life","text":"<p>A constructor is a special method that runs automatically when you create a new object. Think of it as the \"birth certificate\" process for objects; it ensures every new customer gets properly registered with valid information before they can interact with the banking system.</p> <pre><code>// Default constructor - creates empty customer\npublic Customer() {\n    // Java provides this automatically if we don't write one\n    // But it leaves all fields with default values (0, null)\n}\n\n// Parameterized constructor - creates customer with data\npublic Customer(int id, String name, int age, String address) {\n    // Validation before assignment\n    if (id &lt;= 0) {\n        System.out.println(\"Customer ID must be positive\");\n    }\n    if (name == null || name.isEmpty()) {\n        System.out.println(\"Customer name cannot be empty\");\n    }\n    if (age &lt; 18 || age &gt; 120) {\n        System.out.println(\"Invalid age for banking customer\");\n    }\n    if (address == null || address.isEmpty()) {\n        System.out.println(\"Address is required\");\n    }\n\n    this.id = id;\n    this.name = name;\n    this.age = age;\n    this.address = address;\n}\n</code></pre> <p>Notice how the parameterized constructor validates each piece of data before storing it. In banking, you can't have customers with negative IDs, empty names, or unrealistic ages. The constructor acts as a gatekeeper, ensuring only valid customers enter your system.</p> <p>Here's how you create actual customer objects:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Creating customers with validated data\n        Customer customer1 = new Customer(1815, \"Ada Lovelace\", 36, \"10 St. Jame Square, London, England\");\n        Customer customer2 = new Customer(1912, \"Alan Turing\", 41, \"Sherborne School, Dorset, England\");\n        // This would throw an error due to validation:\n        // Customer badCustomer = new Customer(-1, \"\", 15, \"\");\n    }\n}\n</code></pre>"},{"location":"01-fundamentals/classes-objects/#getters-and-setters-controlled-access","title":"Getters and Setters - Controlled Access","text":"<p>Even with proper construction, we need controlled ways to access and modify customer data. Direct field access in banking would be like giving everyone the vault combination\u2014technically possible, but catastrophically dangerous.</p> <pre><code>public class Customer {\n    private int id;\n    private String name;\n    private int age;\n    private String address;\n\n    // Constructor code here...\n\n    // Constructor code here...\n\n    // Getters - safe data retrieval\n    public int getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    // Setters - controlled data modification\n    public void setName(String name) {\n        if (name == null || name.isEmpty()) {\n            System.out.println(\"Name cannot be empty\");\n        }\n        this.name = name;\n    }\n\n    public void setAge(int age) {\n        if (age &lt; 18 || age &gt; 120) {\n            System.out.println(\"Invalid age for banking customer\");\n        }\n        this.age = age;\n    }\n\n    public void setAddress(String address) {\n        if (address == null || address.isEmpty()) {\n            System.out.println(\"Address cannot be empty\");\n        }\n        this.address = address;\n    }\n\n    // Note: No setter for ID - customer IDs should never change!\n</code></pre>"},{"location":"01-fundamentals/classes-objects/#why-this-protection-matters","title":"Why This Protection Matters","text":"<p>Getters provide read-only access to data without exposing the internal structure. Setters act as security checkpoints, validating every change before it's applied. Notice there's no <code>setId()</code> method; customer IDs are permanent identifiers that should never change after creation.</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        Customer customer2 = new Customer(1912, \"Alan Turing\", 41, \"Sherborne School, Dorset, England\");\n\n         // Safe data access\n        System.out.println(\"Customer: \" + customer2.getName());\n        System.out.println(\"Age: \" + customer2.getAge());\n\n        // Test setter methods - Alan Turing moves to Bletchley Park\n        customer2.setAge(30);\n        customer2.setAddress(\"Bletchley Park, Buckinghamshire, England\");\n        System.out.println(\"Age: \" + customer2.getAge());\n        System.out.println(\"Address: \" + customer2.getAdress()());\n    }\n}\n</code></pre> <p>This encapsulation creates a robust system where customer data remains consistent and valid throughout the object's lifetime, exactly as real banking systems require for regulatory compliance and data integrity.</p>"},{"location":"01-fundamentals/classes-objects/#adding-behavior-methods-and-tostring","title":"Adding Behavior - Methods and toString","text":""},{"location":"01-fundamentals/classes-objects/#the-tostring-method","title":"The toString Method","text":"<p>Every object in Java inherits a <code>toString()</code> method from the <code>Object</code> class, but by default it returns something cryptic like <code>Customer@2a84aee7</code>; hardly useful when you need to understand what's in your object. In banking software, being able to clearly display customer information is crucial for debugging, logging, and user interfaces.</p> <p>Let's override the <code>toString()</code> method to provide meaningful output:</p> <pre><code>class Customer {\n    // private variables here\n    // Constructor and getter/setter methods here...\n\n    @Override\n    public String toString() {\n        return String.format(\"Customer{id=%d, name='%s', age=%d, address='%s'}\", \n                        id, name, age, address);\n    }\n}\n</code></pre> <p>The <code>@Override</code> annotation tells the compiler we're intentionally replacing the parent class method. This provides compile-time safety\u2014if we accidentally misspell the method name, we'll get an error instead of creating a new method.</p> <p>Now when you print a customer object, you get professional, readable output:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n\n        Customer customer2 = new Customer(1912, \"Alan Turing\", 41, \"Sherborne School, Dorset, England\");    \n        System.out.println(customer2);  // Automatically calls toString()\n        // Output: Customer{id=1912, name='Alan Turing', age=41, address='herborne School, Dorset, England'}\n\n        // Great for logging\n        System.out.println(\"Customer created: \" + customer2.toString());\n    }\n}\n</code></pre>"},{"location":"01-fundamentals/classes-objects/#business-logic-methods","title":"Business Logic Methods","text":"<p>Beyond basic data access, objects should encapsulate business behavior. Let's add methods that make sense for a banking customer:</p> <pre><code>class Customer {\n\n    public void displayCustomerInfo() {\n        System.out.println(\"=== Customer Information ===\");\n        System.out.println(\"ID: \" + id);\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Age: \" + age);\n        System.out.println(\"Address: \" + address);\n        System.out.println(\"==========================\");\n    }\n\n    // Business logic method - check if eligible for senior discount\n    public boolean isEligibleForSeniorDiscount() {\n        return age &gt;= 65;\n    }\n}\n</code></pre> <p>These methods transform your <code>Customer</code> class from a simple data container into an intelligent object that knows how to display itself, validate its own data, and apply business rules. This encapsulation of both data and behavior is the essence of object-oriented programming; objects that are responsible for their own operations and maintain their own integrity.</p>"},{"location":"01-fundamentals/classes-objects/#building-the-account-class","title":"Building the Account Class","text":""},{"location":"01-fundamentals/classes-objects/#account-structure","title":"Account Structure","text":"<p>Now that we have customers, we need accounts to hold their money. An <code>Account</code> class represents the financial core of our banking system, handling sensitive data that requires even stricter protection than customer information.</p> <pre><code>public class Account {\n\n\n    /** Current balance in the account */\n    private double balance;\n\n    /**\n     * Constructs a new Account with zero balance.\n     */\n    public Account() {\n        this.balance = 0.0;\n    }\n\n    /**\n     * Constructs a new Account with the specified initial balance.\n     * \n     * @param initialBalance the starting balance for the account\n     */\n    public Account(double initialBalance) {\n        this.balance = initialBalance;\n    }\n}\n</code></pre> <p>Notice we have two constructors here\u2014this is called constructor overloading. The default constructor creates an account with zero balance, while the parameterized constructor allows you to specify an initial balance. Java automatically chooses which constructor to use based on the arguments you provide when creating an object.</p> <p>The <code>balance</code> field is marked <code>private</code>, demonstrating encapsulation at its most critical level. In banking, the account balance is the most sensitive piece of data\u2014no external code should be able to directly modify it. All changes must go through controlled methods that validate the operations.</p>"},{"location":"01-fundamentals/classes-objects/#core-banking-operations","title":"Core Banking Operations","text":"<p>The real power of the <code>Account</code> class lies in its methods that safely handle money transactions. Each method includes validation and provides clear feedback about the operation's success or failure:</p> <pre><code>public class Account {\n\n    /** Current balance in the account */\n    private double balance;\n\n    /**\n     * Constructs a new Account with zero balance.\n     */\n    public Account() {\n        this.balance = 0.0;\n    }\n\n    /**\n     * Constructs a new Account with the specified initial balance.\n     * \n     * @param initialBalance the starting balance for the account\n     */\n    public Account(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    /**\n     * Deposits the specified amount into the account.\n     * \n     * @param amount the amount to deposit (must be positive)\n     * @return true if deposit was successful, false otherwise\n     */\n    public boolean deposit(double amount) {\n        if (amount &gt; 0) {\n            balance += amount;\n            System.out.println(\"Deposited: $\" + amount);\n            return true;\n        } else {\n            System.out.println(\"Deposit amount must be positive.\");\n            return false;\n        }\n    }\n\n    /**\n     * Withdraws the specified amount from the account.\n     * \n     * @param amount the amount to withdraw (must be positive and not exceed balance)\n     * @return true if withdrawal was successful, false otherwise\n     */\n    public boolean withdraw(double amount) {\n        if (amount &lt;= 0) {\n            System.out.println(\"Withdrawal amount must be positive.\");\n            return false;\n        }\n\n        if (amount &gt; balance) {\n            System.out.println(\"Insufficient funds. Current balance: $\" + balance);\n            return false;\n        }\n\n        balance -= amount;\n        System.out.println(\"Withdrawn: $\" + amount);\n        return true;\n    }\n\n    /**\n     * Returns the current account balance.\n     * \n     * @return the current balance\n     */\n    public double getBalance() {\n        return balance;\n    }\n\n    /**\n     * Returns a string representation of the account.\n     * \n     * @return a formatted string showing the account balance\n     */\n    @Override\n    public String toString() {\n        return \"Account{balance=\u20ac\" + String.format(\"%.2f\", balance) + \"}\";\n    }\n}\n</code></pre>"},{"location":"01-fundamentals/classes-objects/#why-this-design-works","title":"Why This Design Works","text":"<p>This <code>Account</code> implementation demonstrates several key object-oriented principles:</p> <ul> <li>Encapsulation: The <code>balance</code> field is private and can only be modified through controlled methods</li> <li>Validation: Both <code>deposit()</code> and <code>withdraw()</code> methods validate inputs before making changes</li> <li>Feedback: Methods return boolean values to indicate success/failure and print informative messages</li> <li>Data Integrity: The balance can never be set to invalid values through direct access</li> <li>Professional Representation: The <code>toString()</code> method provides a clean, formatted display</li> </ul> <p>The beauty of this design is its simplicity combined with safety. The <code>Account</code> class protects its most critical data (the balance) while providing intuitive methods for common banking operations. This demonstrates how object-oriented programming creates robust, maintainable code that mirrors real-world business processes.</p>"},{"location":"01-fundamentals/classes-objects/#main-class-putting-it-all-together","title":"Main Class - Putting It All Together","text":""},{"location":"01-fundamentals/classes-objects/#the-application-entry-point","title":"The Application Entry Point","text":"<p>The <code>main</code> method is the entry point of any Java application\u2014it's where your program starts executing. Think of it as the director of a play, orchestrating all the objects and demonstrating how they work together. Our <code>BankSystemMain</code> class serves as both a test environment and a showcase of our object-oriented banking system.</p> <pre><code>public class BankingSystemMain {\n    /**\n     * Main method to test Customer and Account functionality.\n     * \n     * @param args command line arguments (not used)\n     */\n    public static void main(String[] args) {\n        System.out.println(\"=== Bank Management System - Week 1 Demo ===\");\n        System.out.println(\"Featuring Computer Science Legends!\\n\");\n\n        // The main method coordinates everything\n    }\n\n}\n</code></pre> <p>Notice how the <code>main</code> method is <code>public static void</code>\u2014this special signature tells the Java Virtual Machine where to start your program. The <code>String[] args</code> parameter allows the program to receive command-line arguments, though we're not using them here.</p> <p>The real magic happens when we start creating and using our objects:</p> <pre><code>// Create customer objects with famous computer scientists\nCustomer customer1 = new Customer(1815, \"Ada Lovelace\", 36, \"10 St. James Square, London, England\");\nCustomer customer2 = new Customer(1912, \"Alan Turing\", 41, \"Sherborne School, Dorset, England\");\nCustomer customer3 = new Customer(1906, \"Grace Hopper\", 85, \"Yale University, New Haven, CT\");\n\n// Display customer information using toString()\nSystem.out.println(\"Customer 1: \" + customer1);\nSystem.out.println(\"Customer 2: \" + customer2);\nSystem.out.println(\"Customer 3: \" + customer3);\n</code></pre> <p>Each <code>new Customer()</code> call invokes our constructor, creating three separate objects in memory. When we print them, Java automatically calls the <code>toString()</code> method we implemented, demonstrating how our encapsulated objects present themselves to the outside world.</p>"},{"location":"01-fundamentals/classes-objects/#demonstrating-encapsulation-and-methods","title":"Demonstrating Encapsulation and Methods","text":"<p>The main method serves as a comprehensive test of all the functionality we've built:</p> <pre><code>// Test getter methods on Ada Lovelace\nSystem.out.println(\"Ada Lovelace Details (First Computer Programmer):\");\nSystem.out.println(\"ID: \" + customer1.getId());\nSystem.out.println(\"Name: \" + customer1.getName());\nSystem.out.println(\"Age: \" + customer1.getAge());\nSystem.out.println(\"Address: \" + customer1.getAddress());\n\n// Test setter methods - Alan Turing moves to Bletchley Park\ncustomer2.setAge(30);\ncustomer2.setAddress(\"Bletchley Park, Buckinghamshire, England\");\nSystem.out.println(\"Alan Turing moves to Bletchley Park (Enigma Code Breaker):\");\nSystem.out.println(customer2);\n</code></pre> <p>This demonstrates the power of encapsulation: we can safely access and modify customer data through our controlled getter and setter methods, while the actual fields remain protected from direct manipulation.</p>"},{"location":"01-fundamentals/classes-objects/#real-world-simulation","title":"Real-World Simulation","text":"<p>The main method creates a complete banking scenario, showing how multiple objects interact in a real system:</p> <pre><code>// Create accounts for our computer science legends\nAccount adaAccount = new Account(); // Ada starts from scratch\nAccount alanAccount = new Account(2500.00); // Alan has wartime savings\nAccount graceAccount = new Account(1500.00); // Grace has Navy pay\n\n// Demonstrate constructor overloading\nSystem.out.println(\"Ada's Account (Analytical Engine Fund): \" + adaAccount);\nSystem.out.println(\"Alan's Account (Codebreaking Savings): \" + alanAccount);\nSystem.out.println(\"Grace's Account (COBOL Development Fund): \" + graceAccount);\n</code></pre> <p>Here we see constructor overloading in action: Ada's account uses the default constructor (starting with \u20ac0.00), while Alan and Grace use the parameterized constructor with initial balances.</p>"},{"location":"01-fundamentals/classes-objects/#testing-banking-operations","title":"Testing Banking Operations","text":"<p>The simulation includes comprehensive testing of our banking methods, including both successful operations and error conditions:</p> <pre><code>// Test successful operations\nSystem.out.println(\"Ada receives royalties from her mathematical work:\");\nadaAccount.deposit(1000.00);\n\nSystem.out.println(\"Alan funds his theoretical computer research:\");\nalanAccount.withdraw(500.00);\n\n// Test validation and error handling\nSystem.out.println(\"Invalid deposit attempt:\");\nalanAccount.deposit(-100.00); // Invalid deposit\n\nSystem.out.println(\"Grace tries to withdraw more than available:\");\ngraceAccount.withdraw(3000.00); // Insufficient funds\n</code></pre> <p>This demonstrates how our methods handle both valid and invalid operations, showing the protective power of encapsulation and validation. The account balance remains safe because it can only be modified through our controlled methods.</p>"},{"location":"01-fundamentals/classes-objects/#system-state-display","title":"System State Display","text":"<p>Finally, the main method shows the current state of all objects using the <code>toString()</code> methods:</p> <pre><code>// Final account states\nSystem.out.println(\"Ada Lovelace (First Programmer): \" + adaAccount);\nSystem.out.println(\"Alan Turing (Father of CS): \" + alanAccount);\nSystem.out.println(\"Grace Hopper (Debugging Pioneer): \" + graceAccount);\n</code></pre> <p>The beauty of this approach is that the main method doesn't need to know the internal structure of <code>Customer</code> or <code>Account</code> objects. It simply calls their public methods and lets each object manage its own representation and behavior.</p> <p>When you run this program, you'll see a complete demonstration of object-oriented programming in action: objects being created, methods being called, data being safely modified through encapsulation, and professional output being generated through well-designed <code>toString()</code> methods. The main method orchestrates this entire symphony of objects, proving that our classes work together as a cohesive banking system.</p>"},{"location":"01-fundamentals/classes-objects/#summary","title":"Summary","text":"<p>You've successfully built a complete bank management system while mastering the core concepts of object-oriented programming. Through the <code>Customer</code> and <code>Account</code> classes, you've learned how encapsulation protects sensitive data, constructors ensure valid object creation, and methods provide controlled behavior.</p>"},{"location":"01-fundamentals/classes-objects/#key-concepts-mastered","title":"Key Concepts Mastered","text":"<ul> <li>Classes and Objects: Blueprints vs. actual instances</li> <li>Encapsulation: Private fields with public getter/setter methods for data protection</li> <li>Constructors: Safe object initialization with validation</li> <li>Method Design: Smart behavior like <code>deposit()</code> and <code>withdraw()</code> with proper validation</li> <li>toString(): Professional object representation for debugging and display</li> </ul> <p>Your banking system validates all inputs, prevents common errors (negative deposits, overdrafts), and provides clear feedback\u2014demonstrating the safety principles of real banking software.</p>"},{"location":"01-fundamentals/classes-objects/#complete-code","title":"Complete Code","text":"<p>Find the complete working code in three organized files:</p> <ul> <li><code>Customer.java</code> - Customer management with encapsulation</li> <li><code>Account.java</code> - Banking account with transaction methods  </li> <li><code>BankSystemMain.java</code> - Complete system demonstration</li> </ul>"},{"location":"01-fundamentals/classes-objects/#next-steps","title":"Next Steps","text":"<p>The next tutorial will enhance this system using Collections (Lists) to create more realistic banking relationships. You'll learn how to:</p> <ul> <li>Give customers multiple accounts using <code>ArrayList&lt;Account&gt;</code></li> <li>Connect the <code>Customer</code> and <code>Account</code> classes properly</li> <li>Implement methods like <code>addAccount()</code>, <code>getTotalBalance()</code>, and <code>findAccountByNumber()</code></li> </ul> <p>This will introduce you to one-to-many relationships in object-oriented design and the powerful Java Collections framework.</p>"},{"location":"01-fundamentals/exercises/","title":"Thinking Like an Object-Oriented Designer and Programmer","text":"<p>When designing software, imagine building real-world things as software objects. Each object represents a thing in the system with its own information and actions.</p> <p>To practice this way of thinking, focus on these questions when given a system:</p> <ul> <li>What are the main things (entities) involved?</li> <li>What details (attributes) does each thing have?</li> <li>What actions (behaviors) can each thing perform?</li> <li>How do these things connect or relate to each other?</li> <li>Are there any important details that should be kept private or protected?</li> </ul>"},{"location":"01-fundamentals/exercises/#1-introduction-to-oop","title":"1. Introduction to OOP","text":""},{"location":"01-fundamentals/exercises/#scenario-1-library-management-system","title":"Scenario 1: Library Management System","text":"<p>Imagine you are designing software to help a library keep track of its books and users.</p> <p>Consider these questions:</p> <ul> <li>What are the main things in the library system? Think about both physical things and people.</li> <li>For each main thing, what details are important to store?</li> <li>What actions will each thing need to perform? For example, what can happen to a book?</li> <li>How do the things interact or work together? Which things rely on or connect with others?</li> <li>Which details should be kept private or secure? Why might that be necessary?</li> </ul>"},{"location":"01-fundamentals/exercises/#scenario-2-university-management-system","title":"Scenario 2: University Management System","text":"<p>Now think about software for managing courses, students, and staff at a university.</p> <p>Ask yourself:</p> <ul> <li>What are the key things in a university system?</li> <li>What important details would each thing need to keep track of?</li> <li>What kinds of actions or tasks must those things be able to do?</li> <li>How would these things be connected or related to one another?</li> <li>Are there details that need to be kept confidential? Who should have access to them?</li> </ul> <p>This way of breaking down problems helps you see the system as a group of interacting parts, each with its own role. Taking these steps before writing any code sets a strong foundation for building clear and flexible software.</p>"},{"location":"01-fundamentals/exercises/#hands-on-coding","title":"Hands-On Coding","text":"<p>Let's get practical. Create a class named <code>Book</code> that models a real book with the following features:</p> <ol> <li> <p>Properties (Variables)</p> <ul> <li>Title (text)</li> <li>Author (text)</li> <li>ISBN number (text or number)</li> <li>Number of copies available (whole number)</li> </ul> </li> <li> <p>Constructor</p> <ul> <li>Create a way to set all these properties when a new <code>Book</code> object is created.</li> </ul> </li> <li> <p>Getters and Setters</p> <ul> <li>Provide methods or functions to safely get (read) and set (modify) each property</li> <li>Make sure the number of copies cannot be set to a negative number.</li> </ul> </li> <li> <p>Methods (Behaviors)</p> <ul> <li>A method to borrow a book: this should reduce the number of available copies by one, but only if there is at least one copy available.</li> <li>A method to return a book: this should increase the number of available copies by one.</li> </ul> </li> </ol>"},{"location":"01-fundamentals/exercises/#2-fundamentals-of-classes-and-objects","title":"2. Fundamentals of Classes and Objects","text":""},{"location":"01-fundamentals/exercises/#project-goal","title":"Project Goal","text":"<p>The goal of this project is to practice Object-Oriented Programming fundamentals by developing a simple University Management System. Each group will design and implement one class independently. After all groups complete their classes, we will integrate them in a main program to demonstrate how individual components can work together to form a complete software system.</p>"},{"location":"01-fundamentals/exercises/#general-requirements-for-all-classes","title":"General Requirements for All Classes","text":"<p>Each class must include:</p> <ul> <li>Private variables as specified in your class requirements</li> <li>Two constructors: a default constructor and a parameterized constructor</li> <li>Getter and setter methods for all private variables</li> <li>toString() method that returns a formatted string representation of the object</li> <li>Additional methods as specified for your class </li> </ul>"},{"location":"01-fundamentals/exercises/#class-1-student","title":"Class 1: Student","text":""},{"location":"01-fundamentals/exercises/#private-variables","title":"Private Variables","text":"<ul> <li><code>studentID</code> (String or int) - Unique identifier for the student</li> <li><code>name</code> (String) - Full name of the student</li> <li><code>GPA</code> (double) - Grade Point Average (0.0 to 4.0)</li> <li><code>enrollmentYear</code> (int) - Year the student enrolled at the university</li> </ul>"},{"location":"01-fundamentals/exercises/#constructors","title":"Constructors","text":"<ol> <li>Default constructor: Initialize all variables with default values (empty strings, 0, etc.)</li> <li>Parameterized constructor: Accept and initialize studentID, name, GPA, and enrollmentYear</li> </ol>"},{"location":"01-fundamentals/exercises/#required-methods","title":"Required Methods","text":"<ul> <li>Getter methods only for studentID and enrollmentYear (these cannot be changed after creation)</li> <li>Getter and setter methods for name</li> <li>Getter method only for GPA (no setter - use updateGPA method instead)</li> <li>updateGPA(double newGPA): Update the student's GPA with validation (must be between 0.0 and 4.0)</li> <li>toString(): Return a formatted string containing all student information</li> <li>calculateAcademicStanding(): Return a String indicating academic standing based on GPA:<ul> <li>\"Good Standing\" if GPA &gt;= 2.0</li> <li>\"Academic Probation\" if GPA &gt;= 1.5 and GPA &lt; 2.0</li> <li>\"Academic Warning\" if GPA &lt; 1.5</li> </ul> </li> </ul>"},{"location":"01-fundamentals/exercises/#class-2-professor","title":"Class 2: Professor","text":""},{"location":"01-fundamentals/exercises/#private-variables_1","title":"Private Variables","text":"<ul> <li><code>employeeID</code> (String or int) - Unique identifier for the professor</li> <li><code>name</code> (String) - Full name of the professor</li> <li><code>specialization</code> (String) - Subject area of expertise (e.g., \"Computer Science\", \"Mathematics\")</li> <li><code>yearsOfExperience</code> (int) - Total years of teaching experience</li> </ul>"},{"location":"01-fundamentals/exercises/#constructors_1","title":"Constructors","text":"<ol> <li>Default constructor: Initialize all variables with default values</li> <li>Parameterized constructor: Accept and initialize employeeID, name, specialization, and yearsOfExperience</li> </ol>"},{"location":"01-fundamentals/exercises/#required-methods_1","title":"Required Methods","text":"<ul> <li>Getter and setter methods for all four variables</li> <li>toString(): Return a formatted string containing all professor information</li> <li>isExperienced(): Return true if <code>yearsOfExperience</code> is greater than <code>5</code>, false otherwise</li> <li>getAcademicTitle(): Return a String with academic title based on experience (e.g., \"Assistant Professor\" for 0-5 years, \"Associate Professor\" for 6-10 years, \"Professor\" for 11+ years)</li> </ul>"},{"location":"01-fundamentals/exercises/#class-3-course","title":"Class 3: Course","text":""},{"location":"01-fundamentals/exercises/#private-variables_2","title":"Private Variables","text":"<ul> <li><code>courseCode</code> (String) - Unique course identifier (e.g., \"CS101\", \"MATH201\")</li> <li><code>courseName</code> (String) - Full name of the course</li> <li><code>credits</code> (int) - Number of credit hours (typically 1-6)</li> <li><code>semester</code> (String) - When the course is offered (e.g., \"Fall 2025\", \"Spring 2026\")</li> </ul>"},{"location":"01-fundamentals/exercises/#constructors_2","title":"Constructors","text":"<ol> <li>Default constructor: Initialize all variables with default values</li> <li>Parameterized constructor: Accept and initialize courseCode, courseName, credits, and semester</li> </ol>"},{"location":"01-fundamentals/exercises/#required-methods_2","title":"Required Methods","text":"<ul> <li>Getter and setter methods for all four variables</li> <li>toString(): Return a formatted string containing all course information</li> <li>displayCourseInfo(): Print complete course details in a readable format</li> <li>isFullCourse(): Return true if credits &gt;= 3, false otherwise</li> <li>getFullCourseName(): Return a String combining <code>courseCode</code> and <code>courseName</code> (e.g., \"CS101: Introduction to Programming\")</li> </ul>"},{"location":"01-fundamentals/exercises/#class-4-classroom","title":"Class 4: Classroom","text":""},{"location":"01-fundamentals/exercises/#private-variables_3","title":"Private Variables","text":"<ul> <li><code>roomNumber</code> (String) - Room identifier (e.g., \"101\", \"A205\")</li> <li><code>buildingName</code> (String) - Name or code of the building</li> <li><code>capacity</code> (int) - Maximum number of students the room can hold</li> <li><code>hasProjector</code> (boolean) - Whether the room has a projector</li> </ul>"},{"location":"01-fundamentals/exercises/#constructors_3","title":"Constructors","text":"<ol> <li>Default constructor: Initialize all variables with default values</li> <li>Parameterized constructor: Accept and initialize roomNumber, buildingName, capacity, and hasProjector</li> </ol>"},{"location":"01-fundamentals/exercises/#required-methods_3","title":"Required Methods","text":"<ul> <li>Getter and setter methods for all four variables</li> <li>toString(): Return a formatted string containing all classroom information</li> <li>displayClassroomInfo(): Print complete classroom details in a readable format</li> <li>isLargeRoom(): Return true if <code>capacity &gt; 50</code>, false otherwise</li> <li>canAccommodate(int numberOfStudents): Accept a number of students and return true if the classroom capacity can accommodate them, false otherwise</li> <li>getFullLocation(): Return a String combining building name and room number (e.g., \"Building A, Room 205\")</li> </ul>"},{"location":"01-fundamentals/exercises/#class-5-department","title":"Class 5: Department","text":""},{"location":"01-fundamentals/exercises/#private-variables_4","title":"Private Variables","text":"<ul> <li><code>departmentName</code> (String) - Name of the department (e.g., \"Computer Science\", \"Mathematics\")</li> <li><code>location</code> (String) - Building or floor where department offices are located</li> <li><code>numberOfFaculty</code> (int) - Total number of faculty members in the department</li> <li><code>departmentHead</code> (String) - Name of the department chairperson</li> </ul>"},{"location":"01-fundamentals/exercises/#constructors_4","title":"Constructors","text":"<ol> <li>Default constructor: Initialize all variables with default values</li> <li>Parameterized constructor: Accept and initialize departmentName, location, numberOfFaculty, and departmentHead</li> </ol>"},{"location":"01-fundamentals/exercises/#required-methods_4","title":"Required Methods","text":"<ul> <li>Getter and setter methods for all four variables</li> <li>toString(): Return a formatted string containing all department information</li> <li>displayDepartmentInfo(): Print complete department details in a readable format</li> <li>addFaculty(): Increment the numberOfFaculty by 1</li> <li>removeFaculty(): Decrement the numberOfFaculty by 1 (ensure it doesn't go below 0)</li> <li>isLargeDepartment(): Return true if numberOfFaculty &gt; 20, false otherwise</li> </ul>"},{"location":"01-fundamentals/exercises/#submission-guidelines","title":"Submission Guidelines","text":"<ul> <li>Each group must submit a single <code>.java</code> file containing their class</li> <li>Include proper comments documenting your class, variables, and methods</li> <li>Test your class by creating objects and calling all methods to ensure they work correctly</li> <li>Your class name must match exactly as specified above (Student, Professor, Course, Classroom, or Department)</li> </ul>"},{"location":"01-fundamentals/exercises/#integration","title":"Integration","text":"<p>Once all groups have completed their classes, we will create a main program that:</p> <ul> <li>Creates objects from each class</li> <li>Demonstrates interactions between objects (e.g., a Professor teaching a Course in a Classroom)</li> <li>Shows how independent components combine to form a functional system</li> </ul>"},{"location":"01-fundamentals/exercises/#3-connecting-classes","title":"3. Connecting Classes","text":""},{"location":"01-fundamentals/exercises/#connecting-classes-through-composition-phase-2","title":"Connecting Classes Through Composition - Phase 2","text":"<p>After building classes as standalone components, it is now time to connect them by modifying your class code. You will add variables and ArrayLists of other class types directly into your classes. This demonstrates composition\u2014the \"has-a\" relationship where one class contains objects of another class.</p> <p>We will explore two types of composition relationships:</p> <ol> <li>Single Object Composition - A class contains ONE instance of another class</li> <li>Collection Composition - A class contains an ArrayList of objects from another class</li> </ol>"},{"location":"01-fundamentals/exercises/#relationship-type-1-single-object-composition-has-a","title":"Relationship Type 1: Single Object Composition (Has-A)","text":"<p>One class has a private variable that is an object of another class type. This creates a permanent connection between classes.</p>"},{"location":"01-fundamentals/exercises/#course-has-a-professor","title":"Course HAS-A Professor","text":"<p>Modify the Course class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private Professor instructor;</code></li> </ul> <p>New Methods:</p> <ul> <li><code>public void assignProfessor(Professor p)</code> - Accepts a Professor object and assigns it to instructor</li> <li><code>public Professor getInstructor()</code> - Returns the instructor object</li> <li><code>public String getInstructorName()</code> - Returns the instructor's name (call instructor.getName()), or \"Not Assigned\" if instructor is null</li> </ul> <p>Modify Existing Method:</p> <ul> <li>Update <code>displayCourseInfo()</code> to also print the instructor's name using <code>getInstructorName()</code></li> <li>Update <code>toString()</code> to include instructor information</li> </ul> <p>In main program:</p> <ul> <li>Create a Professor object</li> <li>Create a Course object  </li> <li>Call course.assignProfessor() to connect them</li> <li>Call course.displayCourseInfo() to see the complete course with instructor</li> </ul>"},{"location":"01-fundamentals/exercises/#course-has-a-classroom","title":"Course HAS-A Classroom","text":"<p>Modify the Course class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private Classroom location;</code></li> </ul> <p>New Methods:</p> <ul> <li><code>public void assignClassroom(Classroom c)</code> - Accepts a Classroom object and assigns it to location</li> <li><code>public Classroom getClassroom()</code> - Returns the classroom object</li> <li><code>public String getClassroomLocation()</code> - Returns the full location string (call location.getFullLocation()), or \"Not Assigned\" if location is null</li> </ul> <p>Modify Existing Method:</p> <ul> <li>Update <code>displayCourseInfo()</code> to also print the classroom location</li> <li>Update <code>toString()</code> to include location information</li> </ul>"},{"location":"01-fundamentals/exercises/#professor-belongs-to-department","title":"Professor BELONGS-TO Department","text":"<p>Modify the Professor class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private Department department;</code></li> </ul> <p>New Methods:</p> <ul> <li><code>public void assignDepartment(Department d)</code> - Assigns the professor to a department</li> <li><code>public Department getDepartment()</code> - Returns the department object</li> <li><code>public String getDepartmentName()</code> - Returns the department name, or \"No Department\" if null</li> </ul> <p>Modify Existing Method:</p> <ul> <li>Update <code>displayProfile()</code> to include department name</li> <li>Update <code>toString()</code> to include department information</li> </ul>"},{"location":"01-fundamentals/exercises/#relationship-type-2-collection-composition-has-many-using-arraylist","title":"Relationship Type 2: Collection Composition (Has-Many Using ArrayList)","text":"<p>One class contains an ArrayList of objects from another class. This represents one-to-many relationships.</p> <p>Important: Add this import at the top of your class file: `import java.util.ArrayList;</p>"},{"location":"01-fundamentals/exercises/#course-has-many-students-enrollment","title":"Course HAS-MANY Students (Enrollment)","text":"<p>Modify the Course class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private ArrayList&lt;Student&gt; enrolledStudents;</code></li> </ul> <p>Update Constructor:</p> <ul> <li>In your parameterized constructor, initialize the ArrayList: <code>enrolledStudents = new ArrayList&lt;&gt;();</code></li> </ul> <p>New Methods:</p> <ul> <li><code>public void enrollStudent(Student s)</code> - Adds a student to the enrolledStudents ArrayList</li> <li><code>public void dropStudent(String studentID)</code> - Removes the student with matching ID from the ArrayList (loop through to find)</li> <li><code>public int getEnrollmentCount()</code> - Returns <code>enrolledStudents.size()</code></li> <li><code>public void listEnrolledStudents()</code> - Loops through the ArrayList and prints each student's ID, name, and GPA</li> <li><code>public boolean isStudentEnrolled(String studentID)</code> - Returns true if student with given ID is in the ArrayList</li> </ul> <p>Modify Existing Method:</p> <ul> <li>Update <code>displayCourseInfo()</code> to show enrollment count</li> </ul> <p>In main program:</p> <ul> <li>Create one Course object</li> <li>Create 4-5 Student objects</li> <li>Enroll each student using enrollStudent()</li> <li>Display enrollment count</li> <li>List all enrolled students</li> <li>Drop one student and display updated count</li> </ul>"},{"location":"01-fundamentals/exercises/#department-has-many-professors-faculty-list","title":"Department HAS-MANY Professors (Faculty List)","text":"<p>Modify the Department class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private ArrayList&lt;Professor&gt; facultyList;</code></li> </ul> <p>Update Constructor:</p> <ul> <li>Initialize in parameterized constructor: <code>facultyList = new ArrayList&lt;&gt;();</code></li> </ul> <p>New/Modified Methods:</p> <ul> <li><code>public void addProfessor(Professor p)</code> - Adds a professor to facultyList ArrayList</li> <li><code>public void removeProfessor(String employeeID)</code> - Removes professor with matching ID from ArrayList</li> <li><code>public int getFacultyCount()</code> - Returns <code>facultyList.size()</code> (replace the old numberOfFaculty getter)</li> <li><code>public void listAllFaculty()</code> - Loops through ArrayList and prints each professor's name, specialization, and years of experience</li> <li><code>public Professor findProfessor(String employeeID)</code> - Searches ArrayList and returns the Professor object with matching ID, or null if not found</li> </ul> <p>Update numberOfFaculty:</p> <ul> <li>Remove the setter for numberOfFaculty</li> <li>Make numberOfFaculty a method that returns <code>facultyList.size()</code> instead of a stored variable, OR remove it entirely and just use getFacultyCount()</li> </ul> <p>In main program:</p> <ul> <li>Create one Department object</li> <li>Create 3-4 Professor objects  </li> <li>Add each to the department using addProfessor()</li> <li>List all faculty</li> <li>Display faculty count</li> </ul>"},{"location":"01-fundamentals/exercises/#professor-teaches-many-courses","title":"Professor TEACHES-MANY Courses","text":"<p>Modify the Professor class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private ArrayList&lt;Course&gt; coursesTeaching;</code></li> </ul> <p>Update Constructor:</p> <ul> <li>Initialize in parameterized constructor: <code>coursesTeaching = new ArrayList&lt;&gt;();</code></li> </ul> <p>New Methods:</p> <ul> <li><code>public void assignCourse(Course c)</code> - Adds a course to coursesTeaching ArrayList</li> <li><code>public void removeCourse(String courseCode)</code> - Removes course with matching code from ArrayList</li> <li><code>public int getTeachingLoad()</code> - Returns the number of courses (size of ArrayList)</li> <li><code>public void listCourses()</code> - Loops through ArrayList and prints each course code and name</li> <li><code>public boolean isTeaching(String courseCode)</code> - Returns true if professor teaches course with given code</li> </ul> <p>In main program:</p> <ul> <li>Create one Professor object</li> <li>Create 2-3 Course objects</li> <li>Assign each course to the professor using assignCourse()</li> <li>Display teaching load</li> <li>List all courses the professor teaches</li> </ul>"},{"location":"01-fundamentals/exercises/#complete-integration-example","title":"Complete Integration Example","text":"<p>In main program, demonstrate all relationships:</p> <pre><code>Create Computer Science Department\nCreate 2 Professors (e.g., Smith, Jones)\nAdd both professors to CS Department\n\nCreate 2 Courses (e.g., CS101, CS201)\nAssign Professor Smith to both courses\nAssign both courses to Smith's teaching list\n\nCreate 1 Classroom (e.g., A205)\nAssign classroom to CS101\n\nCreate 5 Students\nEnroll all 5 students in CS101\n\nDisplay complete information showing all connections\n</code></pre>"},{"location":"01-fundamentals/intro-oop/","title":"Introduction to OOP","text":"<p>Object-Oriented Programming (OOP) is a way to design software around things instead of just steps. If basic programming taught variables and functions, OOP asks a bigger question</p> <p>What are the key things in this problem, what do they know, and what can they do? </p> <p>That shift\u2014from actions first to objects first\u2014is the paradigm change. </p> <p>Imagine you are asked to build a simple <code>Student Management System</code> for a small university. The goal is straightforward: let students sign up for courses, let instructors record grades, and let admins view clean reports. The system should be easy to use, keep data consistent, and adapt as policies change.</p> <p>There are some essential things to consider:  - Who uses the system and what they need (e.g., students, instructors, administrators). - The core actions, such as enroll in a course, drop a course, record a grade, generate a transcript. - Basic rules and limits: course capacity, prerequisites, add/drop deadlines. - Data integrity and clarity: one source of truth for student records, courses, and enrollments.</p> <p></p>"},{"location":"01-fundamentals/intro-oop/#why-oop-vs-procedural","title":"Why OOP (vs procedural)","text":"<p>If you were to build this in a procedural language like <code>C</code>, you\u2019d likely write functions that pass around student IDs, course codes, and grade arrays, carefully coordinating who updates what and in which order. </p> <p>As features grow (capacity checks, prerequisites, transcripts), the function calls multiply and it becomes harder to see where each rule truly lives.</p> <p>But, ...</p> <p>OOP models (this) differently </p> <p>Data and behavior travel together inside objects. A Course object owns its roster and capacity rules; a Student requests enrollment; an Enrollment records the student\u2013course\u2013term; a Transcript computes GPA behind a simple method. Responsibilities sit with the thing that owns them, so changes stay local and the system scales without turning into a tangle of cross-cutting updates.</p>"},{"location":"01-fundamentals/intro-oop/#the-four-pillars","title":"The four pillars","text":"<p>Encapsulation keeps an object\u2019s data and its related methods together and limits direct access. In a Student Management System, <code>Course</code> would expose <code>enroll(student)</code> rather than letting outside code edit the roster; this protects integrity and centralizes rules.</p> <p>Abstraction presents a simple interface and hides inner details. A <code>Transcript</code> might offer <code>gpa()</code> and <code>addResult(course, grade)</code> without revealing storage or formulas, so the inside can change without breaking callers.</p> <p>Inheritance shares common traits through a general type and specializes where needed. If Person holds name and email, <code>Student</code> and <code>Professor</code> can extend it with their own responsibilities, reducing duplication and keeping shared updates easy.</p> <p>Polymorphism lets code work with many specific types through a common interface. A notifier that targets a <code>Notifiable</code> role can message <code>Student</code> or <code>Professor</code> the same way, while each decides how to receive it, keeping the system flexible as it grows.</p> <p>Think of the four pillars as four levers that keep a growing codebase simple without dumbing it down. </p> <p>Encapsulation wraps data together with the rules that keep it valid, so changes happen in one safe place instead of leaking across files. Abstraction gives a clean surface to the outside world, so callers talk in the language of the problem while the moving parts stay hidden and free to improve. </p> <p>Inheritance collects what\u2019s truly shared into a common type, so specialization adds details instead of copying the same code again. Polymorphism lets different kinds of things respond to the same request in their own way, so new cases fit without rewriting the caller. </p> <p>Used together, these ideas reduce coupling, make intent obvious, and keep feature work focused where it belongs.</p>"},{"location":"01-fundamentals/intro-oop/#things-to-remember","title":"Things to remember","text":"<ul> <li>Think in objects, not steps: identify the main things in the problem and what each is responsible for.</li> <li>Keep data with its rules: put the logic that protects or updates data next to the data itself.</li> <li>Show a simple surface: expose clear methods for what something does; hide how it does it.</li> <li>Keep changes local: design so new features or policies touch only the objects that own those rules.</li> </ul>"},{"location":"01-fundamentals/intro-oop/#further-learning","title":"Further learning","text":"<ul> <li>These ideas can be tricky at first. To go deeper, explore beginner-friendly tutorials that walk through classes, objects, and the four pillars step by step.</li> <li>Prefer video? Try a short OOP walkthrough for newcomers that illustrates concepts with clear examples.</li> <li>Want practice? Pick a hands-on guide with small projects to apply encapsulation, inheritance, abstraction, and polymorphism right away.</li> </ul>"},{"location":"01-fundamentals/thinking-objects/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"02-core-oop/","title":"Core OOP Principles Overview","text":"<p>Master the four pillars that define object-oriented programming. Build robust, maintainable systems using inheritance, polymorphism, encapsulation, and abstraction with clear examples and practical applications.</p>"},{"location":"02-core-oop/#abstraction-and-encapsulation","title":"Abstraction and Encapsulation","text":"<p>Control access and protect data</p> <p>Master the practice of bundling data and methods while controlling access through visibility modifiers. Learn to create clean interfaces using getters, setters, and proper data hiding techniques.</p> <p>You'll learn: Access modifiers, getter/setter methods, data validation, and maintaining object integrity</p>"},{"location":"02-core-oop/#inheritance","title":"Inheritance","text":"<p>Extend and specialize classes</p> <p>Learn to create class hierarchies where child classes inherit properties and methods from parent classes. Master super and subclass relationships, method overriding, and the IS-A relationship that models real-world specialization.</p> <p>You'll learn: How to extend classes, override methods, use super keyword, and design effective class hierarchies</p>"},{"location":"02-core-oop/#polymorphism","title":"Polymorphism","text":"<p>One interface, many forms</p> <p>Understand how objects of different types can be treated uniformly through method overriding and dynamic binding. Write flexible code that works with multiple object types using the same interface.</p> <p>You'll learn: Method overriding, runtime polymorphism, casting objects, and designing adaptable systems</p>"},{"location":"02-core-oop/#abstract-classes-interfaces","title":"Abstract Classes &amp; Interfaces","text":"<p>Define contracts and common behavior</p> <p>Create abstract classes that provide partial implementations and interfaces that define pure contracts. Learn when to use each approach and how they enable flexible, extensible designs.</p> <p>You'll learn: Abstract classes vs interfaces, implementing contracts, multiple inheritance through interfaces, and designing flexible systems</p> <p>Start here: Begin with Inheritance to understand class relationships, then move through Polymorphism and Encapsulation. Finish with Abstract Classes &amp; Interfaces to see how these principles work together. Complete the exercises after each topic to reinforce the concepts\u2014these principles build on each other.</p>"},{"location":"02-core-oop/abstract-interfaces/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"02-core-oop/encapsulation/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"02-core-oop/exercises/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"02-core-oop/inheritance/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"02-core-oop/polymorphism/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"03-io-exceptions/","title":"File and Exception Handling Overview","text":"<p>Build robust applications that handle errors gracefully and work with external data. Learn to manage exceptions and interact with the file system using streams and modern I/O techniques.</p>"},{"location":"03-io-exceptions/#exception-handling","title":"Exception Handling","text":"<p>Write bulletproof code</p> <p>Master Java's exception handling system to create applications that recover from errors instead of crashing. Learn try-catch blocks, custom exceptions, and best practices for defensive programming.</p> <p>You'll learn: Try-catch-finally blocks, checked vs unchecked exceptions, throwing custom exceptions, and error handling strategies</p>"},{"location":"03-io-exceptions/#files-streams","title":"Files &amp; Streams","text":"<p>Connect to the outside world</p> <p>Work with files and directories using Java's I/O system. Understand byte streams, character streams, buffered I/O, and modern file operations for reading and writing data efficiently.</p> <p>You'll learn: FileInputStream/FileOutputStream, FileReader/FileWriter, buffered streams, and when to use each approach for different file operations</p> <p>Start here: Begin with Exception Handling to understand error management, then move to Files &amp; Streams to work with external data. Complete the exercises after both topics\u2014these skills are essential for real-world applications that must handle unexpected situations and persistent data.</p>"},{"location":"03-io-exceptions/exception-handling.mdfiles-streams/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"03-io-exceptions/exercises/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"03-io-exceptions/files-streams/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"04-modern-java/","title":"Modern Java Overview","text":"<p>Learn the newer Java features that make your code cleaner and more powerful. Use generics for type safety, lambdas and streams for better data processing, and JavaFX to create desktop applications with visual interfaces.</p>"},{"location":"04-modern-java/#generics","title":"Generics","text":"<p>Type-safe, reusable code</p> <p>Learn Java's generics to write code that works with different types while catching errors at compile time. Create classes and methods that can handle multiple data types safely without casting or runtime errors.</p> <p>You'll learn: Generic classes and methods, type parameters, wildcards, and building components that work with different data types safely</p>"},{"location":"04-modern-java/#lambdas-streams","title":"Lambdas &amp; Streams","text":"<p>Functional programming in Java</p> <p>Use lambda expressions and the Stream API to process collections more efficiently. Replace long loops with short, clear operations for filtering, mapping, and reducing data in your programs.</p> <p>You'll learn: Lambda syntax, functional interfaces, stream operations like map/filter/reduce, method references, and processing data collections effectively</p>"},{"location":"04-modern-java/#javafx-gui","title":"JavaFX &amp; GUI","text":"<p>Build desktop applications</p> <p>Create desktop programs with graphical interfaces using JavaFX. Build interactive applications with buttons, text fields, layouts, and event handling for user-friendly software.</p> <p>You'll learn: JavaFX components, scene structure, event handling, layouts, styling with CSS, and building complete desktop applications</p> <p>Start here: Begin with Generics to understand type safety, then learn Lambdas &amp; Streams for data processing. Finish with JavaFX &amp; GUI to build visual applications. Complete the exercises after each topic\u2014these features will make your Java code more effective and modern.</p>"},{"location":"04-modern-java/exercises/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"04-modern-java/generics/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"04-modern-java/javafx-gui/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"04-modern-java/lambdas-streams/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"projects/","title":"Projects Overview","text":"<p>Apply your Java OOP knowledge through progressive building projects. Each sprint focuses on specific concepts, building from simple applications to complex systems that showcase your programming skills.</p>"},{"location":"projects/#sprint-1-early-concepts","title":"Sprint 1 - Early Concepts","text":"<p>Build your first object-oriented application</p> <p>Create a simple program using classes, objects, and basic collections. Focus on proper class design, object creation, and managing data with arrays or ArrayList. This sprint reinforces foundation concepts through practical coding.</p> <p>You'll build: A basic application like a student management system, library catalog, or inventory tracker using fundamental OOP concepts</p>"},{"location":"projects/#sprint-2-oop-principles","title":"Sprint 2 - OOP Principles","text":"<p>Design with inheritance and polymorphism</p> <p>Expand your application using inheritance hierarchies, method overriding, and polymorphic behavior. Implement proper encapsulation with access modifiers and create abstract classes or interfaces for flexible design.</p> <p>You'll build: An extended version of your Sprint 1 project with class hierarchies, specialized subclasses, and polymorphic method calls</p>"},{"location":"projects/#sprint-3-advanced-integration","title":"Sprint 3 - Advanced Integration","text":"<p>Handle real-world challenges</p> <p>Add robust error handling with exceptions and persistent data storage using file I/O. Integrate multiple advanced concepts to create a complete, professional application that handles unexpected situations gracefully.</p> <p>You'll build: A full-featured application with exception handling, file persistence, and advanced OOP design patterns</p>"},{"location":"projects/#final-project","title":"Final Project","text":"<p>Showcase your mastery</p> <p>Design and implement a comprehensive Java application that demonstrates all course concepts. Include modern Java features like generics, lambdas, and optionally a graphical interface. This capstone project shows your complete OOP programming skills.</p> <p>You'll build: A substantial application of your choice that incorporates the full range of Java OOP techniques learned throughout the course</p> <p>Start here: Begin Sprint 1 after completing the Foundations section. Work through each sprint in order, as they build upon previous work. Take time to plan your application design before coding\u2014good planning makes implementation smoother and more successful.</p>"},{"location":"projects/final_project/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"projects/sprint-1/","title":"Sprint 1 - Early Concepts","text":""},{"location":"projects/sprint-1/#goal","title":"Goal","text":"<p>Turn a real-world use case into a minimal, working OOP skeleton that models key entities and relationships using classes, objects, and collections, supported by a class diagram and short documentation.</p> <p>Emphasize Foundations: Fundamentals of OOP, Classes and Objects, Arrays/Lists, and Thinking in Objects, ensuring clear encapsulation and basic interactions between objects.</p>"},{"location":"projects/sprint-1/#key-elements","title":"Key elements","text":"Element Details Topics covered Fundamentals of OOP, Classes &amp; Objects, Arrays/Lists, Thinking in Objects. Teams 2\u20134 students per team; team must remain the same for all sprints. Points Semester project: 30 points; Sprint 1: 10 points. Deadline November 4 (end of day). Submission One team submission: repository link (or ZIP) containing requirements brief, class diagram (PNG/PDF), and the code developed. Point distribution Project defense 3 pts, Class Diagram 2 pts, Core Classes 4 pts, Documentation 1 pt."},{"location":"projects/sprint-1/#what-to-deliver","title":"What to deliver","text":"<p>You must deliver one zipped folder per group that contains all Sprint 1 materials. The zipped folder must include</p> <ul> <li>Two-page document: include the project goal, a concise list of key expected functionalities, and a requirements brief mapping core user actions to initial entities and relationships for Sprint 1 scope, with an embedded UML class diagram showing classes, key attributes, and associations/multiplicities</li> <li>Source code: implement 2\u20133 core classes with constructors, fields, and methods that collaborate using at least one collection (for example, a List) to demonstrate encapsulation and basic object interactions reflective of the Foundations topics.</li> </ul>"},{"location":"projects/sprint-1/#project-ideas","title":"Project ideas","text":"<p>Choose a project your team finds interesting and useful, and make sure it directly uses the key topics we are focusing on right now: OOP, Collections, and Thinking in Objects.</p> <p>Keep Sprint 1 small and focused: define a few real-world entities as classes, show how they relate, and use lists or other collections to support simple actions and data flows.</p> <p>Write clean, readable code and include a simple class diagram; advanced features can wait for later sprints once your foundation is solid and easy to extend. Below are some suggested ideas to get you started.</p>"},{"location":"projects/sprint-1/#university-management-system","title":"University Management System:","text":"<p>Start with Students, Courses, Instructors, and Enrollments so you can add students to courses and list who is enrolled where. Keep it simple: create the core classes and basic methods to enroll and view enrollments, using a list to store relationships. Later sprints can add grading, schedules, or departments after the basics work well.</p>"},{"location":"projects/sprint-1/#library-management-system","title":"Library Management System","text":"<p>Start with Books, Members, and Loans so you can check out and return books and see what is available. Keep it simple: create the core classes and a list of current loans to track availability and due dates at a basic level. Later sprints can add reservations, fines, or reports once the core flow is stable.</p>"},{"location":"projects/sprint-1/#attendance-management-system","title":"Attendance Management System","text":"<p>Start with Users, Sessions, and AttendanceRecords so you can mark attendance and list who attended which session. Keep it simple: create the core classes and use a list or map to store records, with a minimal difference between admin, faculty, and student roles for now. Later sprints can add summaries and filters by date or course after the basics work</p>"},{"location":"projects/sprint-2/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"projects/sprint-3/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"resources/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"}]}