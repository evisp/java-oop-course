{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Java Object-Oriented Programming Course","text":"<p>Learn modern Java OOP by building. Clear concepts, practical examples, and projects that develop real programming skills.</p>"},{"location":"#who-its-for","title":"Who it's for","text":"<ul> <li>Students (at University Metropolitan Tirana) learning object-oriented programming concepts.</li> <li>Developers comfortable with basic programming who want to master Java OOP.</li> <li>Anyone seeking a structured approach to Java without unnecessary complexity.</li> </ul>"},{"location":"#whats-inside","title":"What's inside","text":"<p>Foundations: Build your OOP foundation with classes, objects, collections, and object-oriented thinking.</p> <p>Core OOP Principles: Master inheritance, polymorphism, encapsulation, and abstract programming.</p> <p>File and Exception Handling: Write robust applications that handle errors and work with external data.</p> <p>Modern Java: Use generics, lambdas, streams, and JavaFX for contemporary Java development.</p> <p>Projects: Apply your knowledge through progressive sprints and a capstone project.</p> <p>Resources: Reference materials, tools, and extended learning resources.</p>"},{"location":"#suggested-path","title":"Suggested path","text":"<ul> <li>Foundations first: Introduction to OOP \u2192 Classes &amp; Objects \u2192 Arrays &amp; Collections \u2192 Thinking in Objects.</li> <li>Core principles: Inheritance \u2192 Polymorphism \u2192 Encapsulation \u2192 Abstract Classes &amp; Interfaces.</li> <li>Practical skills: Exception Handling \u2192 Files &amp; Streams.</li> <li>Modern features: Generics \u2192 Lambdas &amp; Streams \u2192 JavaFX &amp; GUI.</li> <li>Build projects throughout to reinforce learning.</li> </ul>"},{"location":"#study-tips","title":"Study tips","text":"<ul> <li>Code every example yourself - reading code is not the same as writing it.</li> <li>Complete the exercises in each section before moving forward.</li> <li>Start each project sprint when you finish the related concepts.</li> <li>Explain concepts to others - teaching reveals what you truly understand.</li> </ul>"},{"location":"#word-of-encouragement","title":"Word of encouragement","text":"<p>Object-oriented programming changes how you think about code. Start simple, practice consistently, and build real projects.</p> <p>When concepts feel abstract, write more code. When projects feel overwhelming, return to the fundamentals and take smaller steps.</p> <p>Every expert was once a beginner. Keep coding, keep building, keep learning.</p>"},{"location":"00-tools/","title":"IDEs for This Course","text":"<p>A good IDE makes Java work smoother. The course recommends Eclipse, but IntelliJ IDEA, NetBeans, and VS Code are also fine. Pick what feels comfortable and runs well on your computer.</p> <p></p>"},{"location":"00-tools/#your-options","title":"Your options","text":"<ul> <li>Eclipse (recommended): Free, reliable, and well-suited for learning. Strong Java support, debugging, and project tools.</li> <li>IntelliJ IDEA: Polished experience and powerful features. Community Edition is free; Ultimate is paid.</li> <li>NetBeans: Simple to set up with solid Java and Maven support out of the box.</li> <li>VS Code: Lightweight editor that becomes a Java IDE with the Java Extension Pack.</li> </ul>"},{"location":"00-tools/#why-we-recommend-eclipse","title":"Why we recommend Eclipse","text":"<p>Eclipse gives a common setup for everyone, is easy to work with, and is fully capable for the course. It works well on Windows, macOS, and Linux, and has everything needed for projects, debugging, and refactoring.</p>"},{"location":"00-tools/#can-i-use-something-else","title":"Can I use something else?","text":"<p>Yes. All course materials and projects work in any of the IDEs above. If unsure, start with Eclipse. Switching later is easy once the basics are in place.</p>"},{"location":"00-tools/#next-steps","title":"Next steps","text":"<ul> <li>New to Java tools? Install Eclipse first and run a short <code>Hello, World</code> to confirm your setup.</li> <li>Comfortable with another IDE? Use it. Just make sure a recent JDK (e.g., Java 21) is installed and selected in the IDE settings.</li> </ul>"},{"location":"00-tools/eclipse-setup/","title":"Eclipse IDE Setup on Windows","text":"<p>This tutorial shows how to install and set up Eclipse for Java development on Windows. It also explains how to check or set the JDK inside Eclipse and run a quick test project. Estimated time: 20\u201330 minutes.</p>"},{"location":"00-tools/eclipse-setup/#why-this-matters","title":"Why this matters","text":"<ul> <li>Problem: Java work is slower without a stable IDE and a correct JDK setup. Installing tools wrong leads to errors and lost time.</li> <li>Practical benefits: Eclipse gives project templates, code completion, refactoring, and a good debugger, so learning and building Java apps is faster.</li> <li>Professional context: Eclipse is widely used in classrooms and industry, and supports current Java releases. Knowing it is useful for internships and jobs.</li> </ul>"},{"location":"00-tools/eclipse-setup/#prerequisites-and-goals","title":"Prerequisites and goals","text":"<ul> <li>Required: Windows 10 or 11 and a few GB of disk space.</li> <li>Nice to have: A recent JDK (Java 21+). If not installed, Eclipse can still run if bundled with a JRE, but a proper JDK is recommended.</li> <li>You will learn: Download and install Eclipse, set the JDK in Eclipse, and create and run a simple Java project.</li> </ul>"},{"location":"00-tools/eclipse-setup/#high-level-plan","title":"High-level plan","text":"<p>Download Eclipse, install it, confirm Java, set the JDK if needed, then build and run a <code>Hello, World</code> project to verify everything.</p>"},{"location":"00-tools/eclipse-setup/#step-by-step","title":"Step-by-step","text":""},{"location":"00-tools/eclipse-setup/#step-1-download-eclipse","title":"Step 1 \u2014 Download Eclipse","text":"<ul> <li>Go to the official Eclipse downloads page and get the Eclipse Installer for Windows (x86_64). Save the <code>.exe</code> file.</li> </ul>"},{"location":"00-tools/eclipse-setup/#step-2-run-the-installer","title":"Step 2 \u2014 Run the installer","text":"<ul> <li>Open the downloaded <code>.exe</code>. Choose <code>Eclipse IDE for Java Developers.</code></li> <li>Keep the default install folder unless a different location is required. Accept the license and click <code>Install</code></li> <li>When finished, click <code>Launch</code> to start Eclipse.</li> </ul>"},{"location":"00-tools/eclipse-setup/#step-3-choose-a-workspace","title":"Step 3 \u2014 Choose a workspace","text":"<ul> <li>On first launch, pick a workspace folder where projects will be saved (for example, <code>C:\\Users\\YourName\\EclipseWorkspace</code>). Check <code>Use this as default</code> to skip this prompt next time.</li> </ul>"},{"location":"00-tools/eclipse-setup/#step-4-check-or-set-the-jdk-in-eclipse","title":"Step 4 \u2014 Check or set the JDK in Eclipse","text":"<ul> <li>Check the detected Java: <code>Window \u2192 Preferences \u2192 Java \u2192 Installed JREs</code>. If a JDK is listed and checked, you are set.</li> <li>If empty or only a JRE is listed:<ul> <li>Install a JDK (for example, Java 21 or newer) using Oracle or another trusted vendor.</li> <li>In Eclipse: <code>Window \u2192 Preferences \u2192 Java \u2192 Installed JREs \u2192 Add \u2192 Standard VM \u2192 Next</code>. Point JRE home to the JDK folder (e.g., <code>C:\\Program Files\\Java\\jdk-21</code>). Select it as default.</li> </ul> </li> <li>Why this matters: A JDK includes the compiler and tools needed for Java development; a JRE alone is not enough.</li> </ul>"},{"location":"00-tools/eclipse-setup/#step-5-create-and-run-a-test-project","title":"Step 5 \u2014 Create and run a test project","text":"<ul> <li>Create project: <code>File \u2192 New \u2192 Java Project \u2192 Name: HelloWorld \u2192 Finish</code>.</li> <li>Create class: <code>Right-click src \u2192 New \u2192 Class \u2192 Name: Main \u2192 Finish.</code></li> <li>Paste and run: <pre><code>public class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello, Eclipse!\");\n    }\n}\n</code></pre></li> <li>Click the <code>Run</code> button (green triangle) or press <code>Ctrl+F11</code>. The Console should show: <code>Hello, Eclipse!</code></li> </ul>"},{"location":"00-tools/eclipse-setup/#common-issues-and-quick-fixes","title":"Common issues and quick fixes","text":"<ul> <li>Eclipse won\u2019t start: Make sure you downloaded the 64\u2011bit installer for 64\u2011bit Windows. Re-download if the file was corrupted.</li> <li><code>No Java virtual machine</code> message: Install a JDK and set it in Installed JREs as shown above.</li> <li>Wrong Java version used by a project: <code>Right\u2011click project \u2192 Properties \u2192 Java Build Path \u2192 Libraries</code>; or Java Compiler to select the correct level.</li> </ul>"},{"location":"00-tools/eclipse-setup/#next-steps","title":"Next steps","text":"<ul> <li>Learn shortcuts: <code>Rename (Alt+Shift+R)</code>, <code>Open Type (Ctrl+Shift+T)</code>, <code>Search (Ctrl+H)</code>.</li> <li>Turn on line numbers: <code>Window \u2192 Preferences \u2192 General \u2192 Editors \u2192 Text Editors \u2192 Show line numbers</code>.</li> <li>Connect Git: <code>Window \u2192 Perspective \u2192 Open Perspective \u2192 Git</code>; then clone the course repository.</li> </ul> <p>With Eclipse installed and a test project running, the environment is ready for the course work. Keep the setup simple, and move on to coding.</p>"},{"location":"01-fundamentals/","title":"Foundations Overview","text":"<p>Build the core concepts that power object-oriented programming. Clear explanations, practical examples, and exercises that establish the foundation for everything that follows</p> <p></p>"},{"location":"01-fundamentals/#introduction-to-oop","title":"Introduction to OOP","text":"<p>From procedures to objects</p> <p>Understand why object-oriented programming dictates how we structure code. Learn the fundamental shift from writing step-by-step procedures to modeling real-world entities as objects with properties and behaviors.</p> <p>You'll learn: Why OOP matters, the core principles that guide object design, and how to think in terms of objects rather than functions</p>"},{"location":"01-fundamentals/#classes-objects","title":"Classes &amp; Objects","text":"<p>Blueprints and instances</p> <p>Master the building blocks of Java OOP. Create your first classes, instantiate objects, define constructors, and understand how objects interact through methods and fields.</p> <p>You'll learn: How to design classes, create objects, write constructors and methods, and manage object state</p>"},{"location":"01-fundamentals/#arrays-collections","title":"Arrays &amp; Collections","text":"<p>Managing groups of data</p> <p>Work with collections of objects using arrays and ArrayList. Learn when to use each approach and how to store, access, and manipulate groups of related data efficiently.</p> <p>You'll learn: Array fundamentals, ArrayList operations, choosing the right collection type, and iterating through data</p>"},{"location":"01-fundamentals/#thinking-in-objects","title":"Thinking in Objects","text":"<p>The object-oriented mindset</p> <p>Develop the problem-solving approach that distinguishes object-oriented design. Learn to identify objects in real-world problems, define their responsibilities, and model relationships between them.</p> <p>You'll learn: How to decompose problems into objects, assign responsibilities, and design clean object interactions</p> <p>Start here: Begin with Introduction to OOP, then work through each topic in order. Complete the exercises after each section to reinforce your understanding\u2014practice builds intuition.</p>"},{"location":"01-fundamentals/arrays-lists/","title":"Collections and Class Relationships","text":""},{"location":"01-fundamentals/arrays-lists/#introduction-why-evolve-what-works","title":"Introduction - Why Evolve What Works","text":"<p>Last week you built a minimal working version of a banking system with <code>Customer</code> and <code>Account</code> classes. The foundation was solid: encapsulated fields, validated constructors, and methods that protected sensitive data. But real banking systems have additional requirements that expose limitations in the initial design.</p> <p>Consider what happens when a customer opens multiple accounts over time. Your current system can create individual <code>Account</code> objects, but there's no natural way for a <code>Customer</code> to manage their collection of accounts. You need methods to add new accounts, close old ones, search by account number, and calculate total holdings across all accounts. Arrays would require knowing the maximum number of accounts in advance and manual resizing logic.</p> <p>This tutorial refines your banking system to handle more complexity. You'll upgrade the <code>Account</code> class to use <code>static</code> fields properly for class-level identity management, and transform the <code>Customer</code> class to manage multiple accounts using ArrayList\u2014Java's dynamic, resizable collection.</p> <p>The starting code is available at: github.com/evisp/java-oop-course/week2_classes_objects</p> <p>By the end, you'll understand when static belongs at the class level rather than the object level, how to manage object collections idiomatically with <code>ArrayList</code>, and how to design methods that separate concerns cleanly\u2014preparing you for the next step of adding transaction history and deeper object relationships.</p> <p></p>"},{"location":"01-fundamentals/arrays-lists/#upgrading-the-account-class","title":"Upgrading the Account Class","text":"<p>The original <code>Account</code> class handled balance and basic transactions, but lacked two critical features: unique identification and the ability to freeze accounts for security. Real banks need both\u2014every account must have a permanent ID, and suspicious activity requires the ability to freeze accounts temporarily.</p>"},{"location":"01-fundamentals/arrays-lists/#adding-account-identity-with-static-fields","title":"Adding Account Identity with Static Fields","text":"<p>Every bank account needs a unique identifier that never changes. You could manually assign IDs when creating accounts, but that's error-prone and tedious. Instead, we'll use a static field to automatically generate unique IDs.</p>"},{"location":"01-fundamentals/arrays-lists/#understanding-static-class-level-vs-object-level-data","title":"Understanding Static: Class-Level vs Object-Level Data","text":"<p>Until now, every field you've seen belongs to individual objects. When you create three <code>Account</code> objects, each has its own <code>balance</code> field storing different values. This is instance-level data\u2014each object instance maintains its own copy.</p> <p>But some data doesn't belong to any single object; it belongs to the entire class. Think of it like this: if each account is a bank customer, the counter that assigns new customer numbers belongs to the bank itself, not to any individual customer.</p> <p>Here's the key distinction:</p> <pre><code>public class Account {\n    private double balance;          // Instance field: each account has its own balance\n    private static int accountCounter = 1000;  // Static field: shared by ALL accounts\n}\n</code></pre> <p>The <code>static</code> keyword means this field exists at the class level. There's only one <code>accountCounter</code> shared across all <code>Account</code> objects. When any account increments it, all future accounts see the new value.</p>"},{"location":"01-fundamentals/arrays-lists/#why-static-matters-for-id-generation","title":"Why Static Matters for ID Generation","text":"<p>Static fields are perfect for ID generation because you need exactly one counter shared across all accounts:</p> <pre><code>public class Account {\n    /** Static counter for generating unique account IDs */\n    private static int accountCounter = 1000;\n\n    /** Unique identifier for this account */\n    private int accountId;\n\n    /** Current balance in the account */\n    private double balance;\n</code></pre> <p>Notice the pattern: <code>accountCounter</code> is static (class-level, shared), while <code>accountId</code> is instance-level (each account has its own ID). The counter generates IDs; each account stores the ID it received.</p>"},{"location":"01-fundamentals/arrays-lists/#generating-ids-in-the-constructor","title":"Generating IDs in the Constructor","text":"<p>The constructor is the perfect place to assign IDs because every account must get one at birth:</p> <pre><code>/**\n * Constructs a new Account with zero balance and active status.\n * Automatically assigns a unique account ID.\n */\npublic Account() {\n    this.accountId = ++accountCounter;  // Increment counter, then assign\n    this.balance   = 0.0;\n}\n\n/**\n * Constructs a new Account with the specified initial balance and active status.\n * Automatically assigns a unique account ID.\n * \n * @param initialBalance the starting balance for the account (must be non-negative)\n */\npublic Account(double initialBalance) {\n    if (initialBalance &lt; 0) {\n        System.out.println(\"Initial balance cannot be negative. Provided: \u20ac\" + initialBalance);\n    }\n    this.accountId = ++accountCounter;  // Same ID generation logic\n    this.balance   = initialBalance;\n}\n</code></pre> <p>The expression <code>++accountCounter</code> is crucial: it increments the static counter first, then returns the new value. This ensures each account gets a unique, sequential ID starting from 1001, 1002, 1003, and so on.</p>"},{"location":"01-fundamentals/arrays-lists/#accessing-static-vs-instance-fields","title":"Accessing Static vs Instance Fields","text":"<p>This is where many programmers make mistakes. Static fields belong to the class, not to objects:</p> <pre><code>// WRONG: accessing static field through an object\nAccount acc = new Account();\nint counter = acc.accountCounter;  // Bad style - static accessed through instance\n\n// CORRECT: accessing static field through the class\nint counter = Account.accountCounter;  // Good - but only if accountCounter were public\n</code></pre> <p>Since <code>accountCounter</code> is private, external code can't access it directly. If you needed to expose it (for reporting, for example), you'd add a static getter:</p> <pre><code>/**\n * Returns the current account counter value.\n * \n * @return the next account ID that will be assigned\n */\npublic static int getAccountCounter() {\n    return accountCounter;\n}\n</code></pre> <p>Notice the getter is also <code>static</code>\u2014it accesses static data, so it must be a static method.</p>"},{"location":"01-fundamentals/arrays-lists/#adding-the-account-id-getter","title":"Adding the Account ID Getter","text":"<p>Each account needs to expose its own ID through a regular (non-static) getter:</p> <pre><code>/**\n * Returns the unique account ID.\n * \n * @return the account ID\n */\npublic int getAccountId() {\n    return accountId;\n}\n</code></pre> <p>This is an instance method because it returns data specific to each account object.</p>"},{"location":"01-fundamentals/arrays-lists/#adding-account-freeze-capability","title":"Adding Account Freeze Capability","text":"<p>Banks need the ability to freeze accounts when fraud is suspected or legal issues arise. A frozen account should reject all transactions until unfrozen.</p>"},{"location":"01-fundamentals/arrays-lists/#the-isfrozen-field","title":"The isFrozen Field","text":"<p>Add a new instance field to track freeze status:</p> <pre><code>public class Account {\n    private static int accountCounter = 1000;\n    private int accountId;\n    private double balance;\n\n    /** Status of the account (active or frozen) */\n    private boolean isFrozen;\n}\n</code></pre> <p>Every account starts unfrozen, so initialize it in both constructors:</p> <pre><code>public Account() {\n    this.accountId = ++accountCounter;\n    this.balance   = 0.0;\n    this.isFrozen  = false;  // New accounts are active\n}\n\npublic Account(double initialBalance) {\n    if (initialBalance &lt; 0) {\n        System.out.println(\"Initial balance cannot be negative. Provided: \u20ac\" + initialBalance);\n    }\n    this.accountId = ++accountCounter;\n    this.balance   = initialBalance;\n    this.isFrozen  = false;  // New accounts are active\n}\n</code></pre>"},{"location":"01-fundamentals/arrays-lists/#freeze-and-unfreeze-methods","title":"Freeze and Unfreeze Methods","text":"<p>Add methods to control the freeze state:</p> <pre><code>/**\n * Checks if the account is frozen.\n * \n * @return true if account is frozen, false otherwise\n */\npublic boolean isFrozen() {\n    return isFrozen;\n}\n\n/**\n * Freezes the account, preventing withdrawals and deposits.\n */\npublic void freezeAccount() {\n    this.isFrozen = true;\n    System.out.println(\"Account #\" + accountId + \" has been frozen.\");\n}\n\n/**\n * Unfreezes the account, allowing normal operations.\n */\npublic void unfreezeAccount() {\n    this.isFrozen = false;\n    System.out.println(\"Account #\" + accountId + \" has been unfrozen.\");\n}\n</code></pre> <p>Notice how the freeze methods reference <code>accountId</code> in their messages\u2014this is why having unique IDs matters for logging and auditing.</p>"},{"location":"01-fundamentals/arrays-lists/#enforcing-freeze-in-transactions","title":"Enforcing Freeze in Transactions","text":"<p>Now update <code>deposit()</code> and <code>withdraw()</code> to check freeze status before processing:</p> <pre><code>/**\n * Deposits the specified amount into the account.\n * \n * @param amount the amount to deposit (must be positive)\n * @return true if deposit was successful, false otherwise\n */\npublic boolean deposit(double amount) {\n    if (isFrozen) {\n        System.out.println(\"Cannot deposit. Account #\" + accountId + \" is frozen.\");\n        return false;\n    }\n\n    if (amount &gt; 0) {\n        balance += amount;\n        System.out.println(\"Deposited: \u20ac\" + amount + \" to Account #\" + accountId);\n        return true;\n    } else {\n        System.out.println(\"Deposit amount must be positive.\");\n        return false;\n    }\n}\n\n/**\n * Withdraws the specified amount from the account.\n * \n * @param amount the amount to withdraw (must be positive and not exceed balance)\n * @return true if withdrawal was successful, false otherwise\n */\npublic boolean withdraw(double amount) {\n    if (isFrozen) {\n        System.out.println(\"Cannot withdraw. Account #\" + accountId + \" is frozen.\");\n        return false;\n    }\n\n    if (amount &lt;= 0) {\n        System.out.println(\"Withdrawal amount must be positive.\");\n        return false;\n    }\n\n    if (amount &gt; balance) {\n        System.out.println(\"Insufficient funds. Current balance: \u20ac\" + balance);\n        return false;\n    }\n\n    balance -= amount;\n    System.out.println(\"Withdrawn: \u20ac\" + amount + \" from Account #\" + accountId);\n    return true;\n}\n</code></pre> <p>The freeze check comes first in both methods, creating a security barrier that prevents any transaction on frozen accounts.</p>"},{"location":"01-fundamentals/arrays-lists/#updating-tostring-for-complete-information","title":"Updating toString for Complete Information","text":"<p>The <code>toString()</code> method should now show the ID and freeze status:</p> <pre><code>/**\n * Returns a string representation of the account.\n * \n * @return a formatted string showing the account details\n */\n@Override\npublic String toString() {\n    String status = isFrozen ? \"[FROZEN]\" : \"[ACTIVE]\";\n    return \"Account{\" +\n            \"id=\" + accountId +\n            \", balance=\u20ac\" + String.format(\"%.2f\", balance) +\n            \", status=\" + status +\n            '}';\n}\n</code></pre> <p>Now when you print an account, you see its complete state: ID, balance, and security status.</p>"},{"location":"01-fundamentals/arrays-lists/#testing-the-enhanced-account","title":"Testing the Enhanced Account","text":"<p>Here's how the new features work in practice:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Create accounts - IDs auto-generated\n        Account acc1 = new Account(500.0);\n        Account acc2 = new Account(1000.0);\n\n        System.out.println(acc1);  // Account{id=1001, balance=\u20ac500.00, status=[ACTIVE]}\n        System.out.println(acc2);  // Account{id=1002, balance=\u20ac1000.00, status=[ACTIVE]}\n\n        // Freeze an account\n        acc1.freezeAccount();  // Account #1001 has been frozen.\n\n        // Try transactions on frozen account\n        acc1.deposit(100.0);   // Cannot deposit. Account #1001 is frozen.\n        acc1.withdraw(50.0);   // Cannot withdraw. Account #1001 is frozen.\n\n        // Unfreeze and retry\n        acc1.unfreezeAccount(); // Account #1001 has been unfrozen.\n        acc1.deposit(100.0);    // Deposited: \u20ac100.0 to Account #1001\n\n        System.out.println(acc1);  // Account{id=1001, balance=\u20ac600.00, status=[ACTIVE]}\n    }\n}\n</code></pre>"},{"location":"01-fundamentals/arrays-lists/#why-this-design-works","title":"Why This Design Works","text":"<p>Static for shared identity: One counter ensures all accounts get unique, sequential IDs without manual coordination.</p> <p>Instance fields for object state: Each account maintains its own balance, ID, and freeze status independently.</p> <p>Security layering: Freeze checks at the method entry points create a single, consistent enforcement point.</p> <p>Clear representation: The <code>toString()</code> method shows all critical information at a glance for debugging and logging.</p> <p>The Account class now handles real banking requirements: automatic unique identification through static fields, and security controls through instance state. Next, you'll see how the Customer class uses collections to manage multiple accounts like these.</p>"},{"location":"01-fundamentals/arrays-lists/#building-customer-account-relationships-with-arraylist","title":"Building Customer-Account Relationships with ArrayList","text":"<p>The original <code>Customer</code> class stored personal information but had no way to manage accounts. In real banking, customers open multiple accounts over time: checking accounts, savings accounts, investment accounts. Your code needs to reflect this one-to-many relationship: one customer, many accounts.</p>"},{"location":"01-fundamentals/arrays-lists/#the-one-to-many-relationship-problem","title":"The One-to-Many Relationship Problem","text":"<p>Consider what you'd need without collections:</p> <pre><code>// Inflexible approach - what if customer needs more than 3 accounts?\nprivate Account account1;\nprivate Account account2;\nprivate Account account3;\n</code></pre> <p>This doesn't scale. You'd need separate fields for every possible account, manual null checks everywhere, and custom logic for searching. Arrays would be slightly better but still require knowing the maximum account count in advance and manually shifting elements when removing accounts.</p> <p>ArrayList solves this elegantly. It's a dynamic, resizable collection that grows and shrinks automatically. </p> <p>You add accounts as needed, remove them when closed, and search without worrying about array bounds or null slots.</p>"},{"location":"01-fundamentals/arrays-lists/#adding-the-arraylist-import-and-field","title":"Adding the ArrayList Import and Field","text":"<p>First, import ArrayList from the Java Collections Framework:</p> <pre><code>import java.util.ArrayList;\n</code></pre> <p>Then add the collection field to Customer:</p> <pre><code>public class Customer {\n    private int id;\n    private String name;\n    private int age;\n    private String address;\n\n    /** List of accounts owned by this customer */\n    private ArrayList&lt;Account&gt; accounts;\n}\n</code></pre> <p>The syntax <code>ArrayList&lt;Account&gt;</code> uses generics\u2014it tells Java this list will only hold <code>Account</code> objects. The compiler enforces this, preventing you from accidentally adding the wrong type of object.</p>"},{"location":"01-fundamentals/arrays-lists/#initializing-the-arraylist","title":"Initializing the ArrayList","text":"<p>Collections must be initialized before use. The constructor is the right place:</p> <pre><code>/**\n * Constructs a new Customer with the specified details.\n * Initializes an empty list of accounts.\n * \n * @param id the unique customer identifier\n * @param name the customer's full name\n * @param age the customer's age\n * @param address the customer's address\n */\npublic Customer(int id, String name, int age, String address) {\n    this.id       = id;\n    this.name     = name;\n    this.age      = age;\n    this.address  = address;\n    this.accounts = new ArrayList&lt;&gt;();  // Start with empty list\n}\n</code></pre> <p>The <code>new ArrayList&lt;&gt;()</code> creates an empty list ready to accept <code>Account</code> objects. The diamond operator <code>&lt;&gt;</code> lets Java infer the type from the field declaration, avoiding repetition.</p>"},{"location":"01-fundamentals/arrays-lists/#understanding-encapsulation-with-collections","title":"Understanding Encapsulation with Collections","text":"<p>Notice <code>accounts</code> is <code>private</code>. This is crucial, because external code shouldn't access the internal list directly. If you exposed it with a simple getter:</p> <pre><code>// DANGEROUS: don't do this\npublic ArrayList&lt;Account&gt; getAccounts() {\n    return accounts;  // Returns direct reference to internal list\n}\n</code></pre> <p>Any code could then add, remove, or modify accounts without going through your validation logic. Instead, you provide controlled methods that maintain the integrity of the relationship.</p>"},{"location":"01-fundamentals/arrays-lists/#adding-accounts-the-addaccount-method","title":"Adding Accounts: The addAccount Method","text":"<p>The first relationship method lets customers open new accounts:</p> <pre><code>/**\n * Adds a new account to this customer's account list.\n * \n * @param account the account to add\n * @return true if account was successfully added\n */\npublic boolean addAccount(Account account) {\n    if (account == null) {\n        System.out.println(\"Cannot add null account.\");\n        return false;\n    }\n    accounts.add(account);\n    System.out.println(\"Account #\" + account.getAccountId() + \" added to customer \" + name);\n    return true;\n}\n</code></pre> <p>This method demonstrates three key principles:</p> <ul> <li>Validation: Check for null before adding to prevent runtime errors later.</li> <li>Encapsulation: External code can't manipulate the list directly; it must go through this method.</li> <li>Feedback: Returns a boolean indicating success and prints a confirmation message.</li> </ul> <p>The <code>add()</code> method is provided by ArrayList and appends the new account to the end of the list. No manual array management required.</p>"},{"location":"01-fundamentals/arrays-lists/#removing-accounts-the-removeaccount-method","title":"Removing Accounts: The removeAccount Method","text":"<p>When customers close accounts, you need to remove them from the list:</p> <pre><code>/**\n * Removes an account from this customer's account list.\n * \n * @param account the account to remove\n * @return true if account was found and removed, false otherwise\n */\npublic boolean removeAccount(Account account) {\n    if (accounts.remove(account)) {\n        System.out.println(\"Account #\" + account.getAccountId() + \" removed from customer \" + name);\n        return true;\n    } else {\n        System.out.println(\"Account not found for customer \" + name);\n        return false;\n    }\n}\n</code></pre> <p>The ArrayList <code>remove()</code> method searches for the object and removes it if found, returning <code>true</code> on success and <code>false</code> if the object wasn't in the list. This handles the search and removal in one operation.</p>"},{"location":"01-fundamentals/arrays-lists/#searching-for-accounts-the-findaccount-method","title":"Searching for Accounts: The findAccount Method","text":"<p>Customers need to interact with specific accounts, so you need a search method:</p> <pre><code>/**\n * Searches for an account by its account ID.\n * \n * @param accountId the ID of the account to find\n * @return the Account if found, null otherwise\n */\npublic Account findAccount(int accountId) {\n    for (Account account : accounts) {\n        if (account.getAccountId() == accountId) {\n            return account;\n        }\n    }\n    return null;\n}\n</code></pre> <p>This uses the enhanced for-each loop, Java's clean syntax for iterating over collections:</p> <pre><code>for (Account account : accounts) {\n    // account is each element in the accounts list, one at a time\n}\n</code></pre> <p>Read this as \"for each account in accounts.\" It's much cleaner than traditional index-based loops and works with any collection type.</p> <p>The method performs a linear search: it checks each account until it finds a matching ID, then returns that account. If no match is found, it returns <code>null</code>.</p>"},{"location":"01-fundamentals/arrays-lists/#getting-the-account-count","title":"Getting the Account Count","text":"<p>A simple utility method to check how many accounts a customer has:</p> <pre><code>/**\n * Returns the total number of accounts owned by this customer.\n * \n * @return the number of accounts\n */\npublic int getAccountCount() {\n    return accounts.size();\n}\n</code></pre> <p>ArrayList's <code>size()</code> method returns the current number of elements\u2014no manual counting needed.</p>"},{"location":"01-fundamentals/arrays-lists/#connecting-customer-and-account-delegation-methods","title":"Connecting Customer and Account: Delegation Methods","text":"<p>Now comes the powerful part: customers can perform banking operations by delegating to their accounts. This demonstrates composition</p> <p>Customer doesn't duplicate Account's deposit/withdraw logic; it coordinates access to the right account.</p>"},{"location":"01-fundamentals/arrays-lists/#depositing-to-a-specific-account","title":"Depositing to a Specific Account","text":"<pre><code>/**\n * Deposits money into a specific account.\n * \n * @param accountId the ID of the account to deposit into\n * @param amount the amount to deposit\n * @return true if deposit was successful, false otherwise\n */\npublic boolean deposit(int accountId, double amount) {\n    Account account = findAccount(accountId);\n    if (account == null) {\n        System.out.println(\"Account #\" + accountId + \" not found for customer \" + name);\n        return false;\n    }\n    return account.deposit(amount);\n}\n</code></pre> <p>This method:</p> <ol> <li>Searches for the account using <code>findAccount()</code></li> <li>Validates that the account exists</li> <li>Delegates the actual deposit to the Account object</li> </ol> <p>The Customer class doesn't know or care about balance validation, freeze checks, or how deposits work\u2014that's Account's job. Customer just routes the operation to the right place.</p>"},{"location":"01-fundamentals/arrays-lists/#withdrawing-from-a-specific-account","title":"Withdrawing from a Specific Account","text":"<p>The withdrawal method follows the same pattern:</p> <pre><code>/**\n * Withdraws money from a specific account.\n * \n * @param accountId the ID of the account to withdraw from\n * @param amount the amount to withdraw\n * @return true if withdrawal was successful, false otherwise\n */\npublic boolean withdraw(int accountId, double amount) {\n    Account account = findAccount(accountId);\n    if (account == null) {\n        System.out.println(\"Account #\" + accountId + \" not found for customer \" + name);\n        return false;\n    }\n    return account.withdraw(amount);\n}\n</code></pre> <p>Again, Customer acts as a coordinator, not a controller. Each class maintains its own responsibilities: Customer manages the collection of accounts, while Account handles its own balance and validation rules.</p>"},{"location":"01-fundamentals/arrays-lists/#calculating-total-balance-across-all-accounts","title":"Calculating Total Balance Across All Accounts","text":"<p>Customers often want to see their total holdings across all accounts:</p> <pre><code>/**\n * Calculates the total balance across all accounts.\n * \n * @return the sum of all account balances\n */\npublic double getTotalBalance() {\n    double total = 0.0;\n    for (Account account : accounts) {\n        total += account.getBalance();\n    }\n    return total;\n}\n</code></pre> <p>This demonstrates aggregation, that is combining data from multiple related objects. The for-each loop iterates through all accounts, asking each for its balance and accumulating the sum.</p> <p>Notice that Customer doesn't access Account's private <code>balance</code> field directly (it can't\u2014it's private). Instead, it uses the public <code>getBalance()</code> getter. Encapsulation is maintained across the relationship.</p>"},{"location":"01-fundamentals/arrays-lists/#displaying-all-accounts","title":"Displaying All Accounts","text":"<p>A utility method to show a customer's complete account portfolio:</p> <pre><code>/**\n * Displays all accounts owned by this customer.\n */\npublic void displayAllAccounts() {\n    System.out.println(\"\\n--- Accounts for \" + name + \" ---\");\n    if (accounts.isEmpty()) {\n        System.out.println(\"No accounts found.\");\n    } else {\n        for (Account account : accounts) {\n            System.out.println(\"  \" + account);\n        }\n        System.out.println(\"Total Balance: \u20ac\" + String.format(\"%.2f\", getTotalBalance()));\n    }\n}\n</code></pre> <p>The <code>isEmpty()</code> method checks if the list has zero elements. If accounts exist, the loop prints each one (automatically calling Account's <code>toString()</code> method), then shows the total balance.</p>"},{"location":"01-fundamentals/arrays-lists/#updating-customers-tostring","title":"Updating Customer's toString","text":"<p>The Customer's string representation should now show account information:</p> <pre><code>/**\n * Returns a string representation of the customer.\n * \n * @return a formatted string containing customer details\n */\n@Override\npublic String toString() {\n    return \"Customer{\" +\n            \"id=\" + id +\n            \", name='\" + name + '\\'' +\n            \", age=\" + age +\n            \", address='\" + address + '\\'' +\n            \", accounts=\" + accounts.size() +\n            \", totalBalance=\u20ac\" + String.format(\"%.2f\", getTotalBalance()) +\n            '}';\n}\n</code></pre> <p>This provides a compact summary: how many accounts and the total balance across all of them.</p>"},{"location":"01-fundamentals/arrays-lists/#testing-the-complete-relationship","title":"Testing the Complete Relationship","text":"<p>Here's how Customer and Account work together:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Create a customer\n        Customer ada = new Customer(1815, \"Ada Lovelace\", 36, \"London, England\");\n\n        // Create and add accounts\n        Account checking = new Account(1000.0);\n        Account savings = new Account(5000.0);\n\n        ada.addAccount(checking);  // Account #1001 added to customer Ada Lovelace\n        ada.addAccount(savings);   // Account #1002 added to customer Ada Lovelace\n\n        System.out.println(ada);  // Shows 2 accounts, total \u20ac6000.00\n\n        // Deposit through Customer\n        ada.deposit(1001, 500.0);  // Deposited: \u20ac500.0 to Account #1001\n\n        // Withdraw through Customer\n        ada.withdraw(1002, 200.0); // Withdrawn: \u20ac200.0 from Account #1002\n\n        // Display complete account information\n        ada.displayAllAccounts();\n        // --- Accounts for Ada Lovelace ---\n        //   Account{id=1001, balance=\u20ac1500.00, status=[ACTIVE]}\n        //   Account{id=1002, balance=\u20ac4800.00, status=[ACTIVE]}\n        // Total Balance: \u20ac6300.00\n\n        // Find and freeze a specific account\n        Account found = ada.findAccount(1001);\n        if (found != null) {\n            found.freezeAccount();  // Account #1001 has been frozen.\n        }\n\n        // Try to deposit to frozen account\n        ada.deposit(1001, 100.0);  // Cannot deposit. Account #1001 is frozen.\n    }\n}\n</code></pre>"},{"location":"01-fundamentals/arrays-lists/#why-this-design-works_1","title":"Why This Design Works","text":"<ul> <li>Single Responsibility: Customer manages the account collection; Account manages its own money and state.</li> <li>Encapsulation: Private list with public methods prevents unauthorized manipulation.</li> <li>Delegation: Customer doesn't duplicate Account logic; it routes operations to the right account.</li> <li>Composition: The Customer-Account relationship reflects real-world banking naturally.</li> <li>Scalability: ArrayList grows dynamically as customers open more accounts without code changes.</li> </ul> <p>The Customer class has evolved from a simple data container into a sophisticated coordinator that manages a one-to-many relationship with accounts, all while maintaining clean separation of concerns and proper encapsulation.</p>"},{"location":"01-fundamentals/arrays-lists/#summary","title":"Summary","text":"<p>You've transformed a basic banking system into one that handles real-world complexity. The upgrades touched two critical areas: class-level identity management and dynamic object relationships.</p>"},{"location":"01-fundamentals/arrays-lists/#key-concepts-mastered","title":"Key Concepts Mastered","text":""},{"location":"01-fundamentals/arrays-lists/#static-fields-for-shared-data","title":"Static fields for shared data","text":"<p>The <code>accountCounter</code> generates unique IDs at the class level, demonstrating when data belongs to the class rather than individual objects. Static fields are shared across all instances, making them perfect for ID generation and shared configuration.</p>"},{"location":"01-fundamentals/arrays-lists/#arraylist-for-dynamic-relationships","title":"ArrayList for dynamic relationships","text":"<p>The <code>Customer</code> class now manages a growing collection of accounts using <code>ArrayList&lt;Account&gt;</code>, eliminating the rigid constraints of arrays. Collections grow and shrink as customers open and close accounts, reflecting real banking operations.</p>"},{"location":"01-fundamentals/arrays-lists/#one-to-many-relationships","title":"One-to-many relationships","text":"<p>Customer coordinates multiple accounts through encapsulated methods\u2014<code>addAccount()</code>, <code>removeAccount()</code>, <code>findAccount()</code>, and <code>getTotalBalance()</code>\u2014demonstrating how objects collaborate while maintaining clear responsibilities.</p>"},{"location":"01-fundamentals/arrays-lists/#delegation-over-duplication","title":"Delegation over duplication","text":"<p>Customer doesn't reimplement deposit and withdrawal logic; it delegates to Account objects. This separation of concerns keeps each class focused on its own responsibilities.</p>"},{"location":"01-fundamentals/arrays-lists/#enhanced-iteration-patterns","title":"Enhanced iteration patterns","text":"<p>The for-each loop provides clean, readable iteration over collections, making code easier to understand and maintain.</p>"},{"location":"01-fundamentals/arrays-lists/#complete-code","title":"Complete Code","text":"<p>Find the complete working code organized by version:</p> <ul> <li>v1_basic_classes - Starting point with simple Customer and Account</li> <li>v2_basic_collections - Enhanced version with static IDs, ArrayList, and relationships</li> </ul>"},{"location":"01-fundamentals/classes-objects/","title":"Classes & Objects","text":""},{"location":"01-fundamentals/classes-objects/#introduction-why-classes-matter","title":"Introduction - Why Classes Matter","text":"<p>Imagine you are tasked with building a digital banking system for a growing financial institution. The system needs to handle customers, their personal information, multiple account types, and secure financial transactions. Traditional programming approaches using separate variables and functions quickly become inefficient when dealing with complex, interconnected data like customer profiles linked to multiple accounts with different balances and transaction histories.</p> <p>Object-oriented programming provides an elegant solution by letting you model real-world entities directly in code. Instead of juggling separate arrays and variables, you create classes that represent actual things: a <code>Customer</code> class that knows its own name, ID, and contact information, and an <code>Account</code> class that manages its own balance and validates its own transactions.</p> <p>We will build a complete bank account management system step by step, starting with fundamental concepts and ending with a working application. Today, you'll create <code>Customer</code> and <code>Account</code> classes that interact naturally.</p> <p>Through this practical project, you will learn the core building blocks of object-oriented programming: how to define classes as blueprints for objects, use constructors to create properly initialized objects, implement encapsulation with getters and setters to protect sensitive data, and override the <code>toString()</code> method for clear object representation. </p> <p></p>"},{"location":"01-fundamentals/classes-objects/#the-blueprint-concept-understanding-classes","title":"The Blueprint Concept - Understanding Classes","text":"<p>Think of a class as an architect's blueprint for a house. The blueprint itself isn't a house you can live in\u2014it's a detailed plan that specifies where the rooms go, how big they should be, and what features each room should have. But from that single blueprint, a construction company can build dozens of identical houses, each one a real, physical structure where families can actually live.</p> <p>In programming, classes work exactly the same way. </p> <p>A class is a blueprint that defines what data an object should contain and what actions it can perform. </p> <p>The class itself doesn't hold any actual data\u2014it's just the template.</p> <p>Objects are the real instances built from that class blueprint, each containing actual values and able to perform real operations.</p> <p>Let's see this concept in action with our banking system. Here's our first empty <code>Customer</code> class\u2014our blueprint:</p> <pre><code>public class Customer {\n    // This is our blueprint - it defines the structure\n    // but doesn't contain any actual customer data yet\n}\n</code></pre> <p>This <code>Customer</code> class is like our architectural blueprint. It exists, but it doesn't represent any specific customer. To create actual customers (objects), we instantiate the class:</p> <pre><code>public class Main {\npublic static void main(String[] args) {\n    // Creating actual Customer objects from our blueprint\n    Customer customer1 = new Customer(); \n    Customer customer2 = new Customer(); \n    // customer1 and customer2 are separate objects (houses)\n    // built from the same Customer class (blueprint)\n}\n</code></pre> <p>Notice the key terminology here: <code>Customer</code> (with capital C) is the class - our blueprint. <code>customer1</code> and <code>customer2</code> are objects or instances - actual customers created from that blueprint. Each object exists independently and can hold different data, just like two houses built from the same blueprint can have different families living in them and different furniture inside.</p> <p>The power of this blueprint concept becomes clear when you realize that from one well-designed class, you can create hundreds or thousands of objects, each managing its own data safely and consistently.</p>"},{"location":"01-fundamentals/classes-objects/#building-our-first-class-customer","title":"Building Our First Class - Customer","text":""},{"location":"01-fundamentals/classes-objects/#class-definition-and-fields","title":"Class Definition and Fields","text":"<p>Now let's add substance to our blueprint. A real customer has essential information: their name, a unique ID, and an email address. But here's where object-oriented programming gets interesting\u2014we need to decide who can access this information and how.</p> <pre><code>public class Customer {\n    // Private fields - the customer's sensitive data\n    private int id;\n    private String name;\n    private int age;\n    private String address;\n    // This data is now protected inside the class\n}\n</code></pre> <p>Notice the <code>private</code> keyword before each field. This is encapsulation in action\u2014we're building walls around our data. Think of it like a bank vault: the money (data) is stored inside, but you can't just walk in and grab it. You need to go through proper channels (methods) to access or modify it.</p>"},{"location":"01-fundamentals/classes-objects/#private-vs-public-access-the-security-difference","title":"Private vs Public Access: The Security Difference","text":"<p>In banking, data protection isn't just good practice\u2014it's legally required. Imagine if anyone could directly change a customer's account balance or ID number:</p> <p>With <code>private</code> fields, this direct manipulation becomes impossible. The compiler will throw an error if external code tries to access private data directly. This forces all interactions to go through controlled methods that we design, where we can add validation, logging, and business logic.</p>"},{"location":"01-fundamentals/classes-objects/#why-encapsulation-matters-in-banking","title":"Why Encapsulation Matters in Banking","text":"<p>Banks handle sensitive financial data that requires multiple layers of protection. Encapsulation provides the first line of defense by ensuring that:</p> <ul> <li>Data Integrity: Customer IDs can't be accidentally set to invalid values</li> <li>Business Rules: Email addresses must follow proper formats  </li> <li>Audit Trails: All data changes go through trackable methods</li> <li>Security: Sensitive information is never exposed directly to external code</li> </ul> <p>When you encapsulate data properly, you create a controlled environment where every interaction with customer information goes through your carefully designed security checkpoints. </p>"},{"location":"01-fundamentals/classes-objects/#the-constructor-bringing-objects-to-life","title":"The Constructor - Bringing Objects to Life","text":"<p>A constructor is a special method that runs automatically when you create a new object. Think of it as the \"birth certificate\" process for objects; it ensures every new customer gets properly registered with valid information before they can interact with the banking system.</p> <pre><code>// Default constructor - creates empty customer\npublic Customer() {\n    // Java provides this automatically if we don't write one\n    // But it leaves all fields with default values (0, null)\n}\n\n// Parameterized constructor - creates customer with data\npublic Customer(int id, String name, int age, String address) {\n    // Validation before assignment\n    if (id &lt;= 0) {\n        System.out.println(\"Customer ID must be positive\");\n    }\n    if (name == null || name.isEmpty()) {\n        System.out.println(\"Customer name cannot be empty\");\n    }\n    if (age &lt; 18 || age &gt; 120) {\n        System.out.println(\"Invalid age for banking customer\");\n    }\n    if (address == null || address.isEmpty()) {\n        System.out.println(\"Address is required\");\n    }\n\n    this.id = id;\n    this.name = name;\n    this.age = age;\n    this.address = address;\n}\n</code></pre> <p>Notice how the parameterized constructor validates each piece of data before storing it. In banking, you can't have customers with negative IDs, empty names, or unrealistic ages. The constructor acts as a gatekeeper, ensuring only valid customers enter your system.</p> <p>Here's how you create actual customer objects:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        // Creating customers with validated data\n        Customer customer1 = new Customer(1815, \"Ada Lovelace\", 36, \"10 St. Jame Square, London, England\");\n        Customer customer2 = new Customer(1912, \"Alan Turing\", 41, \"Sherborne School, Dorset, England\");\n        // This would throw an error due to validation:\n        // Customer badCustomer = new Customer(-1, \"\", 15, \"\");\n    }\n}\n</code></pre>"},{"location":"01-fundamentals/classes-objects/#getters-and-setters-controlled-access","title":"Getters and Setters - Controlled Access","text":"<p>Even with proper construction, we need controlled ways to access and modify customer data. Direct field access in banking would be like giving everyone the vault combination\u2014technically possible, but catastrophically dangerous.</p> <pre><code>public class Customer {\n    private int id;\n    private String name;\n    private int age;\n    private String address;\n\n    // Constructor code here...\n\n    // Constructor code here...\n\n    // Getters - safe data retrieval\n    public int getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public String getAddress() {\n        return address;\n    }\n\n    // Setters - controlled data modification\n    public void setName(String name) {\n        if (name == null || name.isEmpty()) {\n            System.out.println(\"Name cannot be empty\");\n        }\n        this.name = name;\n    }\n\n    public void setAge(int age) {\n        if (age &lt; 18 || age &gt; 120) {\n            System.out.println(\"Invalid age for banking customer\");\n        }\n        this.age = age;\n    }\n\n    public void setAddress(String address) {\n        if (address == null || address.isEmpty()) {\n            System.out.println(\"Address cannot be empty\");\n        }\n        this.address = address;\n    }\n\n    // Note: No setter for ID - customer IDs should never change!\n</code></pre>"},{"location":"01-fundamentals/classes-objects/#why-this-protection-matters","title":"Why This Protection Matters","text":"<p>Getters provide read-only access to data without exposing the internal structure. Setters act as security checkpoints, validating every change before it's applied. Notice there's no <code>setId()</code> method; customer IDs are permanent identifiers that should never change after creation.</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n        Customer customer2 = new Customer(1912, \"Alan Turing\", 41, \"Sherborne School, Dorset, England\");\n\n         // Safe data access\n        System.out.println(\"Customer: \" + customer2.getName());\n        System.out.println(\"Age: \" + customer2.getAge());\n\n        // Test setter methods - Alan Turing moves to Bletchley Park\n        customer2.setAge(30);\n        customer2.setAddress(\"Bletchley Park, Buckinghamshire, England\");\n        System.out.println(\"Age: \" + customer2.getAge());\n        System.out.println(\"Address: \" + customer2.getAdress()());\n    }\n}\n</code></pre> <p>This encapsulation creates a robust system where customer data remains consistent and valid throughout the object's lifetime, exactly as real banking systems require for regulatory compliance and data integrity.</p>"},{"location":"01-fundamentals/classes-objects/#adding-behavior-methods-and-tostring","title":"Adding Behavior - Methods and toString","text":""},{"location":"01-fundamentals/classes-objects/#the-tostring-method","title":"The toString Method","text":"<p>Every object in Java inherits a <code>toString()</code> method from the <code>Object</code> class, but by default it returns something cryptic like <code>Customer@2a84aee7</code>; hardly useful when you need to understand what's in your object. In banking software, being able to clearly display customer information is crucial for debugging, logging, and user interfaces.</p> <p>Let's override the <code>toString()</code> method to provide meaningful output:</p> <pre><code>class Customer {\n    // private variables here\n    // Constructor and getter/setter methods here...\n\n    @Override\n    public String toString() {\n        return String.format(\"Customer{id=%d, name='%s', age=%d, address='%s'}\", \n                        id, name, age, address);\n    }\n}\n</code></pre> <p>The <code>@Override</code> annotation tells the compiler we're intentionally replacing the parent class method. This provides compile-time safety\u2014if we accidentally misspell the method name, we'll get an error instead of creating a new method.</p> <p>Now when you print a customer object, you get professional, readable output:</p> <pre><code>public class Main {\n    public static void main(String[] args) {\n\n        Customer customer2 = new Customer(1912, \"Alan Turing\", 41, \"Sherborne School, Dorset, England\");    \n        System.out.println(customer2);  // Automatically calls toString()\n        // Output: Customer{id=1912, name='Alan Turing', age=41, address='herborne School, Dorset, England'}\n\n        // Great for logging\n        System.out.println(\"Customer created: \" + customer2.toString());\n    }\n}\n</code></pre>"},{"location":"01-fundamentals/classes-objects/#business-logic-methods","title":"Business Logic Methods","text":"<p>Beyond basic data access, objects should encapsulate business behavior. Let's add methods that make sense for a banking customer:</p> <pre><code>class Customer {\n\n    public void displayCustomerInfo() {\n        System.out.println(\"=== Customer Information ===\");\n        System.out.println(\"ID: \" + id);\n        System.out.println(\"Name: \" + name);\n        System.out.println(\"Age: \" + age);\n        System.out.println(\"Address: \" + address);\n        System.out.println(\"==========================\");\n    }\n\n    // Business logic method - check if eligible for senior discount\n    public boolean isEligibleForSeniorDiscount() {\n        return age &gt;= 65;\n    }\n}\n</code></pre> <p>These methods transform your <code>Customer</code> class from a simple data container into an intelligent object that knows how to display itself, validate its own data, and apply business rules. This encapsulation of both data and behavior is the essence of object-oriented programming; objects that are responsible for their own operations and maintain their own integrity.</p>"},{"location":"01-fundamentals/classes-objects/#building-the-account-class","title":"Building the Account Class","text":""},{"location":"01-fundamentals/classes-objects/#account-structure","title":"Account Structure","text":"<p>Now that we have customers, we need accounts to hold their money. An <code>Account</code> class represents the financial core of our banking system, handling sensitive data that requires even stricter protection than customer information.</p> <pre><code>public class Account {\n\n\n    /** Current balance in the account */\n    private double balance;\n\n    /**\n     * Constructs a new Account with zero balance.\n     */\n    public Account() {\n        this.balance = 0.0;\n    }\n\n    /**\n     * Constructs a new Account with the specified initial balance.\n     * \n     * @param initialBalance the starting balance for the account\n     */\n    public Account(double initialBalance) {\n        this.balance = initialBalance;\n    }\n}\n</code></pre> <p>Notice we have two constructors here\u2014this is called constructor overloading. The default constructor creates an account with zero balance, while the parameterized constructor allows you to specify an initial balance. Java automatically chooses which constructor to use based on the arguments you provide when creating an object.</p> <p>The <code>balance</code> field is marked <code>private</code>, demonstrating encapsulation at its most critical level. In banking, the account balance is the most sensitive piece of data\u2014no external code should be able to directly modify it. All changes must go through controlled methods that validate the operations.</p>"},{"location":"01-fundamentals/classes-objects/#core-banking-operations","title":"Core Banking Operations","text":"<p>The real power of the <code>Account</code> class lies in its methods that safely handle money transactions. Each method includes validation and provides clear feedback about the operation's success or failure:</p> <pre><code>public class Account {\n\n    /** Current balance in the account */\n    private double balance;\n\n    /**\n     * Constructs a new Account with zero balance.\n     */\n    public Account() {\n        this.balance = 0.0;\n    }\n\n    /**\n     * Constructs a new Account with the specified initial balance.\n     * \n     * @param initialBalance the starting balance for the account\n     */\n    public Account(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    /**\n     * Deposits the specified amount into the account.\n     * \n     * @param amount the amount to deposit (must be positive)\n     * @return true if deposit was successful, false otherwise\n     */\n    public boolean deposit(double amount) {\n        if (amount &gt; 0) {\n            balance += amount;\n            System.out.println(\"Deposited: $\" + amount);\n            return true;\n        } else {\n            System.out.println(\"Deposit amount must be positive.\");\n            return false;\n        }\n    }\n\n    /**\n     * Withdraws the specified amount from the account.\n     * \n     * @param amount the amount to withdraw (must be positive and not exceed balance)\n     * @return true if withdrawal was successful, false otherwise\n     */\n    public boolean withdraw(double amount) {\n        if (amount &lt;= 0) {\n            System.out.println(\"Withdrawal amount must be positive.\");\n            return false;\n        }\n\n        if (amount &gt; balance) {\n            System.out.println(\"Insufficient funds. Current balance: $\" + balance);\n            return false;\n        }\n\n        balance -= amount;\n        System.out.println(\"Withdrawn: $\" + amount);\n        return true;\n    }\n\n    /**\n     * Returns the current account balance.\n     * \n     * @return the current balance\n     */\n    public double getBalance() {\n        return balance;\n    }\n\n    /**\n     * Returns a string representation of the account.\n     * \n     * @return a formatted string showing the account balance\n     */\n    @Override\n    public String toString() {\n        return \"Account{balance=\u20ac\" + String.format(\"%.2f\", balance) + \"}\";\n    }\n}\n</code></pre>"},{"location":"01-fundamentals/classes-objects/#why-this-design-works","title":"Why This Design Works","text":"<p>This <code>Account</code> implementation demonstrates several key object-oriented principles:</p> <ul> <li>Encapsulation: The <code>balance</code> field is private and can only be modified through controlled methods</li> <li>Validation: Both <code>deposit()</code> and <code>withdraw()</code> methods validate inputs before making changes</li> <li>Feedback: Methods return boolean values to indicate success/failure and print informative messages</li> <li>Data Integrity: The balance can never be set to invalid values through direct access</li> <li>Professional Representation: The <code>toString()</code> method provides a clean, formatted display</li> </ul> <p>The beauty of this design is its simplicity combined with safety. The <code>Account</code> class protects its most critical data (the balance) while providing intuitive methods for common banking operations. This demonstrates how object-oriented programming creates robust, maintainable code that mirrors real-world business processes.</p>"},{"location":"01-fundamentals/classes-objects/#main-class-putting-it-all-together","title":"Main Class - Putting It All Together","text":""},{"location":"01-fundamentals/classes-objects/#the-application-entry-point","title":"The Application Entry Point","text":"<p>The <code>main</code> method is the entry point of any Java application\u2014it's where your program starts executing. Think of it as the director of a play, orchestrating all the objects and demonstrating how they work together. Our <code>BankSystemMain</code> class serves as both a test environment and a showcase of our object-oriented banking system.</p> <pre><code>public class BankingSystemMain {\n    /**\n     * Main method to test Customer and Account functionality.\n     * \n     * @param args command line arguments (not used)\n     */\n    public static void main(String[] args) {\n        System.out.println(\"=== Bank Management System - Week 1 Demo ===\");\n        System.out.println(\"Featuring Computer Science Legends!\\n\");\n\n        // The main method coordinates everything\n    }\n\n}\n</code></pre> <p>Notice how the <code>main</code> method is <code>public static void</code>\u2014this special signature tells the Java Virtual Machine where to start your program. The <code>String[] args</code> parameter allows the program to receive command-line arguments, though we're not using them here.</p> <p>The real magic happens when we start creating and using our objects:</p> <pre><code>// Create customer objects with famous computer scientists\nCustomer customer1 = new Customer(1815, \"Ada Lovelace\", 36, \"10 St. James Square, London, England\");\nCustomer customer2 = new Customer(1912, \"Alan Turing\", 41, \"Sherborne School, Dorset, England\");\nCustomer customer3 = new Customer(1906, \"Grace Hopper\", 85, \"Yale University, New Haven, CT\");\n\n// Display customer information using toString()\nSystem.out.println(\"Customer 1: \" + customer1);\nSystem.out.println(\"Customer 2: \" + customer2);\nSystem.out.println(\"Customer 3: \" + customer3);\n</code></pre> <p>Each <code>new Customer()</code> call invokes our constructor, creating three separate objects in memory. When we print them, Java automatically calls the <code>toString()</code> method we implemented, demonstrating how our encapsulated objects present themselves to the outside world.</p>"},{"location":"01-fundamentals/classes-objects/#demonstrating-encapsulation-and-methods","title":"Demonstrating Encapsulation and Methods","text":"<p>The main method serves as a comprehensive test of all the functionality we've built:</p> <pre><code>// Test getter methods on Ada Lovelace\nSystem.out.println(\"Ada Lovelace Details (First Computer Programmer):\");\nSystem.out.println(\"ID: \" + customer1.getId());\nSystem.out.println(\"Name: \" + customer1.getName());\nSystem.out.println(\"Age: \" + customer1.getAge());\nSystem.out.println(\"Address: \" + customer1.getAddress());\n\n// Test setter methods - Alan Turing moves to Bletchley Park\ncustomer2.setAge(30);\ncustomer2.setAddress(\"Bletchley Park, Buckinghamshire, England\");\nSystem.out.println(\"Alan Turing moves to Bletchley Park (Enigma Code Breaker):\");\nSystem.out.println(customer2);\n</code></pre> <p>This demonstrates the power of encapsulation: we can safely access and modify customer data through our controlled getter and setter methods, while the actual fields remain protected from direct manipulation.</p>"},{"location":"01-fundamentals/classes-objects/#real-world-simulation","title":"Real-World Simulation","text":"<p>The main method creates a complete banking scenario, showing how multiple objects interact in a real system:</p> <pre><code>// Create accounts for our computer science legends\nAccount adaAccount = new Account(); // Ada starts from scratch\nAccount alanAccount = new Account(2500.00); // Alan has wartime savings\nAccount graceAccount = new Account(1500.00); // Grace has Navy pay\n\n// Demonstrate constructor overloading\nSystem.out.println(\"Ada's Account (Analytical Engine Fund): \" + adaAccount);\nSystem.out.println(\"Alan's Account (Codebreaking Savings): \" + alanAccount);\nSystem.out.println(\"Grace's Account (COBOL Development Fund): \" + graceAccount);\n</code></pre> <p>Here we see constructor overloading in action: Ada's account uses the default constructor (starting with \u20ac0.00), while Alan and Grace use the parameterized constructor with initial balances.</p>"},{"location":"01-fundamentals/classes-objects/#testing-banking-operations","title":"Testing Banking Operations","text":"<p>The simulation includes comprehensive testing of our banking methods, including both successful operations and error conditions:</p> <pre><code>// Test successful operations\nSystem.out.println(\"Ada receives royalties from her mathematical work:\");\nadaAccount.deposit(1000.00);\n\nSystem.out.println(\"Alan funds his theoretical computer research:\");\nalanAccount.withdraw(500.00);\n\n// Test validation and error handling\nSystem.out.println(\"Invalid deposit attempt:\");\nalanAccount.deposit(-100.00); // Invalid deposit\n\nSystem.out.println(\"Grace tries to withdraw more than available:\");\ngraceAccount.withdraw(3000.00); // Insufficient funds\n</code></pre> <p>This demonstrates how our methods handle both valid and invalid operations, showing the protective power of encapsulation and validation. The account balance remains safe because it can only be modified through our controlled methods.</p>"},{"location":"01-fundamentals/classes-objects/#system-state-display","title":"System State Display","text":"<p>Finally, the main method shows the current state of all objects using the <code>toString()</code> methods:</p> <pre><code>// Final account states\nSystem.out.println(\"Ada Lovelace (First Programmer): \" + adaAccount);\nSystem.out.println(\"Alan Turing (Father of CS): \" + alanAccount);\nSystem.out.println(\"Grace Hopper (Debugging Pioneer): \" + graceAccount);\n</code></pre> <p>The beauty of this approach is that the main method doesn't need to know the internal structure of <code>Customer</code> or <code>Account</code> objects. It simply calls their public methods and lets each object manage its own representation and behavior.</p> <p>When you run this program, you'll see a complete demonstration of object-oriented programming in action: objects being created, methods being called, data being safely modified through encapsulation, and professional output being generated through well-designed <code>toString()</code> methods. The main method orchestrates this entire symphony of objects, proving that our classes work together as a cohesive banking system.</p>"},{"location":"01-fundamentals/classes-objects/#summary","title":"Summary","text":"<p>You've successfully built a complete bank management system while mastering the core concepts of object-oriented programming. Through the <code>Customer</code> and <code>Account</code> classes, you've learned how encapsulation protects sensitive data, constructors ensure valid object creation, and methods provide controlled behavior.</p>"},{"location":"01-fundamentals/classes-objects/#key-concepts-mastered","title":"Key Concepts Mastered","text":"<ul> <li>Classes and Objects: Blueprints vs. actual instances</li> <li>Encapsulation: Private fields with public getter/setter methods for data protection</li> <li>Constructors: Safe object initialization with validation</li> <li>Method Design: Smart behavior like <code>deposit()</code> and <code>withdraw()</code> with proper validation</li> <li>toString(): Professional object representation for debugging and display</li> </ul> <p>Your banking system validates all inputs, prevents common errors (negative deposits, overdrafts), and provides clear feedback\u2014demonstrating the safety principles of real banking software.</p>"},{"location":"01-fundamentals/classes-objects/#complete-code","title":"Complete Code","text":"<p>Find the complete working code in three organized files:</p> <ul> <li><code>Customer.java</code> - Customer management with encapsulation</li> <li><code>Account.java</code> - Banking account with transaction methods  </li> <li><code>BankSystemMain.java</code> - Complete system demonstration</li> </ul>"},{"location":"01-fundamentals/classes-objects/#next-steps","title":"Next Steps","text":"<p>The next tutorial will enhance this system using Collections (Lists) to create more realistic banking relationships. You'll learn how to:</p> <ul> <li>Give customers multiple accounts using <code>ArrayList&lt;Account&gt;</code></li> <li>Connect the <code>Customer</code> and <code>Account</code> classes properly</li> <li>Implement methods like <code>addAccount()</code>, <code>getTotalBalance()</code>, and <code>findAccountByNumber()</code></li> </ul> <p>This will introduce you to one-to-many relationships in object-oriented design and the powerful Java Collections framework.</p>"},{"location":"01-fundamentals/exercises/","title":"Thinking Like an Object-Oriented Designer and Programmer","text":"<p>When designing software, imagine building real-world things as software objects. Each object represents a thing in the system with its own information and actions.</p> <p>To practice this way of thinking, focus on these questions when given a system:</p> <ul> <li>What are the main things (entities) involved?</li> <li>What details (attributes) does each thing have?</li> <li>What actions (behaviors) can each thing perform?</li> <li>How do these things connect or relate to each other?</li> <li>Are there any important details that should be kept private or protected?</li> </ul>"},{"location":"01-fundamentals/exercises/#1-introduction-to-oop","title":"1. Introduction to OOP","text":""},{"location":"01-fundamentals/exercises/#scenario-1-library-management-system","title":"Scenario 1: Library Management System","text":"<p>Imagine you are designing software to help a library keep track of its books and users.</p> <p>Consider these questions:</p> <ul> <li>What are the main things in the library system? Think about both physical things and people.</li> <li>For each main thing, what details are important to store?</li> <li>What actions will each thing need to perform? For example, what can happen to a book?</li> <li>How do the things interact or work together? Which things rely on or connect with others?</li> <li>Which details should be kept private or secure? Why might that be necessary?</li> </ul>"},{"location":"01-fundamentals/exercises/#scenario-2-university-management-system","title":"Scenario 2: University Management System","text":"<p>Now think about software for managing courses, students, and staff at a university.</p> <p>Ask yourself:</p> <ul> <li>What are the key things in a university system?</li> <li>What important details would each thing need to keep track of?</li> <li>What kinds of actions or tasks must those things be able to do?</li> <li>How would these things be connected or related to one another?</li> <li>Are there details that need to be kept confidential? Who should have access to them?</li> </ul> <p>This way of breaking down problems helps you see the system as a group of interacting parts, each with its own role. Taking these steps before writing any code sets a strong foundation for building clear and flexible software.</p>"},{"location":"01-fundamentals/exercises/#hands-on-coding","title":"Hands-On Coding","text":"<p>Let's get practical. Create a class named <code>Book</code> that models a real book with the following features:</p> <ol> <li> <p>Properties (Variables)</p> <ul> <li>Title (text)</li> <li>Author (text)</li> <li>ISBN number (text or number)</li> <li>Number of copies available (whole number)</li> </ul> </li> <li> <p>Constructor</p> <ul> <li>Create a way to set all these properties when a new <code>Book</code> object is created.</li> </ul> </li> <li> <p>Getters and Setters</p> <ul> <li>Provide methods or functions to safely get (read) and set (modify) each property</li> <li>Make sure the number of copies cannot be set to a negative number.</li> </ul> </li> <li> <p>Methods (Behaviors)</p> <ul> <li>A method to borrow a book: this should reduce the number of available copies by one, but only if there is at least one copy available.</li> <li>A method to return a book: this should increase the number of available copies by one.</li> </ul> </li> </ol>"},{"location":"01-fundamentals/exercises/#2-fundamentals-of-classes-and-objects","title":"2. Fundamentals of Classes and Objects","text":""},{"location":"01-fundamentals/exercises/#project-goal","title":"Project Goal","text":"<p>The goal of this project is to practice Object-Oriented Programming fundamentals by developing a simple University Management System. Each group will design and implement one class independently. After all groups complete their classes, we will integrate them in a main program to demonstrate how individual components can work together to form a complete software system.</p>"},{"location":"01-fundamentals/exercises/#general-requirements-for-all-classes","title":"General Requirements for All Classes","text":"<p>Each class must include:</p> <ul> <li>Private variables as specified in your class requirements</li> <li>Two constructors: a default constructor and a parameterized constructor</li> <li>Getter and setter methods for all private variables</li> <li>toString() method that returns a formatted string representation of the object</li> <li>Additional methods as specified for your class </li> </ul>"},{"location":"01-fundamentals/exercises/#class-1-student","title":"Class 1: Student","text":""},{"location":"01-fundamentals/exercises/#private-variables","title":"Private Variables","text":"<ul> <li><code>studentID</code> (String or int) - Unique identifier for the student</li> <li><code>name</code> (String) - Full name of the student</li> <li><code>GPA</code> (double) - Grade Point Average (0.0 to 4.0)</li> <li><code>enrollmentYear</code> (int) - Year the student enrolled at the university</li> </ul>"},{"location":"01-fundamentals/exercises/#constructors","title":"Constructors","text":"<ol> <li>Default constructor: Initialize all variables with default values (empty strings, 0, etc.)</li> <li>Parameterized constructor: Accept and initialize studentID, name, GPA, and enrollmentYear</li> </ol>"},{"location":"01-fundamentals/exercises/#required-methods","title":"Required Methods","text":"<ul> <li>Getter methods only for studentID and enrollmentYear (these cannot be changed after creation)</li> <li>Getter and setter methods for name</li> <li>Getter method only for GPA (no setter - use updateGPA method instead)</li> <li>updateGPA(double newGPA): Update the student's GPA with validation (must be between 0.0 and 4.0)</li> <li>toString(): Return a formatted string containing all student information</li> <li>calculateAcademicStanding(): Return a String indicating academic standing based on GPA:<ul> <li>\"Good Standing\" if GPA &gt;= 2.0</li> <li>\"Academic Probation\" if GPA &gt;= 1.5 and GPA &lt; 2.0</li> <li>\"Academic Warning\" if GPA &lt; 1.5</li> </ul> </li> </ul>"},{"location":"01-fundamentals/exercises/#class-2-professor","title":"Class 2: Professor","text":""},{"location":"01-fundamentals/exercises/#private-variables_1","title":"Private Variables","text":"<ul> <li><code>employeeID</code> (String or int) - Unique identifier for the professor</li> <li><code>name</code> (String) - Full name of the professor</li> <li><code>specialization</code> (String) - Subject area of expertise (e.g., \"Computer Science\", \"Mathematics\")</li> <li><code>yearsOfExperience</code> (int) - Total years of teaching experience</li> </ul>"},{"location":"01-fundamentals/exercises/#constructors_1","title":"Constructors","text":"<ol> <li>Default constructor: Initialize all variables with default values</li> <li>Parameterized constructor: Accept and initialize employeeID, name, specialization, and yearsOfExperience</li> </ol>"},{"location":"01-fundamentals/exercises/#required-methods_1","title":"Required Methods","text":"<ul> <li>Getter and setter methods for all four variables</li> <li>toString(): Return a formatted string containing all professor information</li> <li>isExperienced(): Return true if <code>yearsOfExperience</code> is greater than <code>5</code>, false otherwise</li> <li>getAcademicTitle(): Return a String with academic title based on experience (e.g., \"Assistant Professor\" for 0-5 years, \"Associate Professor\" for 6-10 years, \"Professor\" for 11+ years)</li> </ul>"},{"location":"01-fundamentals/exercises/#class-3-course","title":"Class 3: Course","text":""},{"location":"01-fundamentals/exercises/#private-variables_2","title":"Private Variables","text":"<ul> <li><code>courseCode</code> (String) - Unique course identifier (e.g., \"CS101\", \"MATH201\")</li> <li><code>courseName</code> (String) - Full name of the course</li> <li><code>credits</code> (int) - Number of credit hours (typically 1-6)</li> <li><code>semester</code> (String) - When the course is offered (e.g., \"Fall 2025\", \"Spring 2026\")</li> </ul>"},{"location":"01-fundamentals/exercises/#constructors_2","title":"Constructors","text":"<ol> <li>Default constructor: Initialize all variables with default values</li> <li>Parameterized constructor: Accept and initialize courseCode, courseName, credits, and semester</li> </ol>"},{"location":"01-fundamentals/exercises/#required-methods_2","title":"Required Methods","text":"<ul> <li>Getter and setter methods for all four variables</li> <li>toString(): Return a formatted string containing all course information</li> <li>displayCourseInfo(): Print complete course details in a readable format</li> <li>isFullCourse(): Return true if credits &gt;= 3, false otherwise</li> <li>getFullCourseName(): Return a String combining <code>courseCode</code> and <code>courseName</code> (e.g., \"CS101: Introduction to Programming\")</li> </ul>"},{"location":"01-fundamentals/exercises/#class-4-classroom","title":"Class 4: Classroom","text":""},{"location":"01-fundamentals/exercises/#private-variables_3","title":"Private Variables","text":"<ul> <li><code>roomNumber</code> (String) - Room identifier (e.g., \"101\", \"A205\")</li> <li><code>buildingName</code> (String) - Name or code of the building</li> <li><code>capacity</code> (int) - Maximum number of students the room can hold</li> <li><code>hasProjector</code> (boolean) - Whether the room has a projector</li> </ul>"},{"location":"01-fundamentals/exercises/#constructors_3","title":"Constructors","text":"<ol> <li>Default constructor: Initialize all variables with default values</li> <li>Parameterized constructor: Accept and initialize roomNumber, buildingName, capacity, and hasProjector</li> </ol>"},{"location":"01-fundamentals/exercises/#required-methods_3","title":"Required Methods","text":"<ul> <li>Getter and setter methods for all four variables</li> <li>toString(): Return a formatted string containing all classroom information</li> <li>displayClassroomInfo(): Print complete classroom details in a readable format</li> <li>isLargeRoom(): Return true if <code>capacity &gt; 50</code>, false otherwise</li> <li>canAccommodate(int numberOfStudents): Accept a number of students and return true if the classroom capacity can accommodate them, false otherwise</li> <li>getFullLocation(): Return a String combining building name and room number (e.g., \"Building A, Room 205\")</li> </ul>"},{"location":"01-fundamentals/exercises/#class-5-department","title":"Class 5: Department","text":""},{"location":"01-fundamentals/exercises/#private-variables_4","title":"Private Variables","text":"<ul> <li><code>departmentName</code> (String) - Name of the department (e.g., \"Computer Science\", \"Mathematics\")</li> <li><code>location</code> (String) - Building or floor where department offices are located</li> <li><code>numberOfFaculty</code> (int) - Total number of faculty members in the department</li> <li><code>departmentHead</code> (String) - Name of the department chairperson</li> </ul>"},{"location":"01-fundamentals/exercises/#constructors_4","title":"Constructors","text":"<ol> <li>Default constructor: Initialize all variables with default values</li> <li>Parameterized constructor: Accept and initialize departmentName, location, numberOfFaculty, and departmentHead</li> </ol>"},{"location":"01-fundamentals/exercises/#required-methods_4","title":"Required Methods","text":"<ul> <li>Getter and setter methods for all four variables</li> <li>toString(): Return a formatted string containing all department information</li> <li>displayDepartmentInfo(): Print complete department details in a readable format</li> <li>addFaculty(): Increment the numberOfFaculty by 1</li> <li>removeFaculty(): Decrement the numberOfFaculty by 1 (ensure it doesn't go below 0)</li> <li>isLargeDepartment(): Return true if numberOfFaculty &gt; 20, false otherwise</li> </ul>"},{"location":"01-fundamentals/exercises/#submission-guidelines","title":"Submission Guidelines","text":"<ul> <li>Each group must submit a single <code>.java</code> file containing their class</li> <li>Include proper comments documenting your class, variables, and methods</li> <li>Test your class by creating objects and calling all methods to ensure they work correctly</li> <li>Your class name must match exactly as specified above (Student, Professor, Course, Classroom, or Department)</li> </ul>"},{"location":"01-fundamentals/exercises/#integration","title":"Integration","text":"<p>Once all groups have completed their classes, we will create a main program that:</p> <ul> <li>Creates objects from each class</li> <li>Demonstrates interactions between objects (e.g., a Professor teaching a Course in a Classroom)</li> <li>Shows how independent components combine to form a functional system</li> </ul>"},{"location":"01-fundamentals/exercises/#3-connecting-classes","title":"3. Connecting Classes","text":""},{"location":"01-fundamentals/exercises/#connecting-classes-through-composition-phase-2","title":"Connecting Classes Through Composition - Phase 2","text":"<p>After building classes as standalone components, it is now time to connect them by modifying your class code. You will add variables and ArrayLists of other class types directly into your classes. This demonstrates composition\u2014the \"has-a\" relationship where one class contains objects of another class.</p> <p>We will explore two types of composition relationships:</p> <ol> <li>Single Object Composition - A class contains ONE instance of another class</li> <li>Collection Composition - A class contains an ArrayList of objects from another class</li> </ol>"},{"location":"01-fundamentals/exercises/#relationship-type-1-single-object-composition-has-a","title":"Relationship Type 1: Single Object Composition (Has-A)","text":"<p>One class has a private variable that is an object of another class type. This creates a permanent connection between classes.</p>"},{"location":"01-fundamentals/exercises/#course-has-a-professor","title":"Course HAS-A Professor","text":"<p>Modify the Course class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private Professor instructor;</code></li> </ul> <p>New Methods:</p> <ul> <li><code>public void assignProfessor(Professor p)</code> - Accepts a Professor object and assigns it to instructor</li> <li><code>public Professor getInstructor()</code> - Returns the instructor object</li> <li><code>public String getInstructorName()</code> - Returns the instructor's name (call instructor.getName()), or \"Not Assigned\" if instructor is null</li> </ul> <p>Modify Existing Method:</p> <ul> <li>Update <code>displayCourseInfo()</code> to also print the instructor's name using <code>getInstructorName()</code></li> <li>Update <code>toString()</code> to include instructor information</li> </ul> <p>In main program:</p> <ul> <li>Create a Professor object</li> <li>Create a Course object  </li> <li>Call course.assignProfessor() to connect them</li> <li>Call course.displayCourseInfo() to see the complete course with instructor</li> </ul>"},{"location":"01-fundamentals/exercises/#course-has-a-classroom","title":"Course HAS-A Classroom","text":"<p>Modify the Course class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private Classroom location;</code></li> </ul> <p>New Methods:</p> <ul> <li><code>public void assignClassroom(Classroom c)</code> - Accepts a Classroom object and assigns it to location</li> <li><code>public Classroom getClassroom()</code> - Returns the classroom object</li> <li><code>public String getClassroomLocation()</code> - Returns the full location string (call location.getFullLocation()), or \"Not Assigned\" if location is null</li> </ul> <p>Modify Existing Method:</p> <ul> <li>Update <code>displayCourseInfo()</code> to also print the classroom location</li> <li>Update <code>toString()</code> to include location information</li> </ul>"},{"location":"01-fundamentals/exercises/#professor-belongs-to-department","title":"Professor BELONGS-TO Department","text":"<p>Modify the Professor class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private Department department;</code></li> </ul> <p>New Methods:</p> <ul> <li><code>public void assignDepartment(Department d)</code> - Assigns the professor to a department</li> <li><code>public Department getDepartment()</code> - Returns the department object</li> <li><code>public String getDepartmentName()</code> - Returns the department name, or \"No Department\" if null</li> </ul> <p>Modify Existing Method:</p> <ul> <li>Update <code>displayProfile()</code> to include department name</li> <li>Update <code>toString()</code> to include department information</li> </ul>"},{"location":"01-fundamentals/exercises/#relationship-type-2-collection-composition-has-many-using-arraylist","title":"Relationship Type 2: Collection Composition (Has-Many Using ArrayList)","text":"<p>One class contains an ArrayList of objects from another class. This represents one-to-many relationships.</p> <p>Important: Add this import at the top of your class file: `import java.util.ArrayList;</p>"},{"location":"01-fundamentals/exercises/#course-has-many-students-enrollment","title":"Course HAS-MANY Students (Enrollment)","text":"<p>Modify the Course class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private ArrayList&lt;Student&gt; enrolledStudents;</code></li> </ul> <p>Update Constructor:</p> <ul> <li>In your parameterized constructor, initialize the ArrayList: <code>enrolledStudents = new ArrayList&lt;&gt;();</code></li> </ul> <p>New Methods:</p> <ul> <li><code>public void enrollStudent(Student s)</code> - Adds a student to the enrolledStudents ArrayList</li> <li><code>public void dropStudent(String studentID)</code> - Removes the student with matching ID from the ArrayList (loop through to find)</li> <li><code>public int getEnrollmentCount()</code> - Returns <code>enrolledStudents.size()</code></li> <li><code>public void listEnrolledStudents()</code> - Loops through the ArrayList and prints each student's ID, name, and GPA</li> <li><code>public boolean isStudentEnrolled(String studentID)</code> - Returns true if student with given ID is in the ArrayList</li> </ul> <p>Modify Existing Method:</p> <ul> <li>Update <code>displayCourseInfo()</code> to show enrollment count</li> </ul> <p>In main program:</p> <ul> <li>Create one Course object</li> <li>Create 4-5 Student objects</li> <li>Enroll each student using enrollStudent()</li> <li>Display enrollment count</li> <li>List all enrolled students</li> <li>Drop one student and display updated count</li> </ul>"},{"location":"01-fundamentals/exercises/#department-has-many-professors-faculty-list","title":"Department HAS-MANY Professors (Faculty List)","text":"<p>Modify the Department class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private ArrayList&lt;Professor&gt; facultyList;</code></li> </ul> <p>Update Constructor:</p> <ul> <li>Initialize in parameterized constructor: <code>facultyList = new ArrayList&lt;&gt;();</code></li> </ul> <p>New/Modified Methods:</p> <ul> <li><code>public void addProfessor(Professor p)</code> - Adds a professor to facultyList ArrayList</li> <li><code>public void removeProfessor(String employeeID)</code> - Removes professor with matching ID from ArrayList</li> <li><code>public int getFacultyCount()</code> - Returns <code>facultyList.size()</code> (replace the old numberOfFaculty getter)</li> <li><code>public void listAllFaculty()</code> - Loops through ArrayList and prints each professor's name, specialization, and years of experience</li> <li><code>public Professor findProfessor(String employeeID)</code> - Searches ArrayList and returns the Professor object with matching ID, or null if not found</li> </ul> <p>Update numberOfFaculty:</p> <ul> <li>Remove the setter for numberOfFaculty</li> <li>Make numberOfFaculty a method that returns <code>facultyList.size()</code> instead of a stored variable, OR remove it entirely and just use getFacultyCount()</li> </ul> <p>In main program:</p> <ul> <li>Create one Department object</li> <li>Create 3-4 Professor objects  </li> <li>Add each to the department using addProfessor()</li> <li>List all faculty</li> <li>Display faculty count</li> </ul>"},{"location":"01-fundamentals/exercises/#professor-teaches-many-courses","title":"Professor TEACHES-MANY Courses","text":"<p>Modify the Professor class by adding:</p> <p>New Private Variable:</p> <ul> <li><code>private ArrayList&lt;Course&gt; coursesTeaching;</code></li> </ul> <p>Update Constructor:</p> <ul> <li>Initialize in parameterized constructor: <code>coursesTeaching = new ArrayList&lt;&gt;();</code></li> </ul> <p>New Methods:</p> <ul> <li><code>public void assignCourse(Course c)</code> - Adds a course to coursesTeaching ArrayList</li> <li><code>public void removeCourse(String courseCode)</code> - Removes course with matching code from ArrayList</li> <li><code>public int getTeachingLoad()</code> - Returns the number of courses (size of ArrayList)</li> <li><code>public void listCourses()</code> - Loops through ArrayList and prints each course code and name</li> <li><code>public boolean isTeaching(String courseCode)</code> - Returns true if professor teaches course with given code</li> </ul> <p>In main program:</p> <ul> <li>Create one Professor object</li> <li>Create 2-3 Course objects</li> <li>Assign each course to the professor using assignCourse()</li> <li>Display teaching load</li> <li>List all courses the professor teaches</li> </ul>"},{"location":"01-fundamentals/exercises/#complete-integration-example","title":"Complete Integration Example","text":"<p>In main program, demonstrate all relationships:</p> <pre><code>Create Computer Science Department\nCreate 2 Professors (e.g., Smith, Jones)\nAdd both professors to CS Department\n\nCreate 2 Courses (e.g., CS101, CS201)\nAssign Professor Smith to both courses\nAssign both courses to Smith's teaching list\n\nCreate 1 Classroom (e.g., A205)\nAssign classroom to CS101\n\nCreate 5 Students\nEnroll all 5 students in CS101\n\nDisplay complete information showing all connections\n</code></pre>"},{"location":"01-fundamentals/intro-oop/","title":"Introduction to OOP","text":"<p>Object-Oriented Programming (OOP) is a way to design software around things instead of just steps. If basic programming taught variables and functions, OOP asks a bigger question</p> <p>What are the key things in this problem, what do they know, and what can they do? </p> <p>That shift\u2014from actions first to objects first\u2014is the paradigm change. </p> <p>Imagine you are asked to build a simple <code>Student Management System</code> for a small university. The goal is straightforward: let students sign up for courses, let instructors record grades, and let admins view clean reports. The system should be easy to use, keep data consistent, and adapt as policies change.</p> <p>There are some essential things to consider:  - Who uses the system and what they need (e.g., students, instructors, administrators). - The core actions, such as enroll in a course, drop a course, record a grade, generate a transcript. - Basic rules and limits: course capacity, prerequisites, add/drop deadlines. - Data integrity and clarity: one source of truth for student records, courses, and enrollments.</p> <p></p>"},{"location":"01-fundamentals/intro-oop/#why-oop-vs-procedural","title":"Why OOP (vs procedural)","text":"<p>If you were to build this in a procedural language like <code>C</code>, you\u2019d likely write functions that pass around student IDs, course codes, and grade arrays, carefully coordinating who updates what and in which order. </p> <p>As features grow (capacity checks, prerequisites, transcripts), the function calls multiply and it becomes harder to see where each rule truly lives.</p> <p>But, ...</p> <p>OOP models (this) differently </p> <p>Data and behavior travel together inside objects. A Course object owns its roster and capacity rules; a Student requests enrollment; an Enrollment records the student\u2013course\u2013term; a Transcript computes GPA behind a simple method. Responsibilities sit with the thing that owns them, so changes stay local and the system scales without turning into a tangle of cross-cutting updates.</p>"},{"location":"01-fundamentals/intro-oop/#the-four-pillars","title":"The four pillars","text":"<p>Encapsulation keeps an object\u2019s data and its related methods together and limits direct access. In a Student Management System, <code>Course</code> would expose <code>enroll(student)</code> rather than letting outside code edit the roster; this protects integrity and centralizes rules.</p> <p>Abstraction presents a simple interface and hides inner details. A <code>Transcript</code> might offer <code>gpa()</code> and <code>addResult(course, grade)</code> without revealing storage or formulas, so the inside can change without breaking callers.</p> <p>Inheritance shares common traits through a general type and specializes where needed. If Person holds name and email, <code>Student</code> and <code>Professor</code> can extend it with their own responsibilities, reducing duplication and keeping shared updates easy.</p> <p>Polymorphism lets code work with many specific types through a common interface. A notifier that targets a <code>Notifiable</code> role can message <code>Student</code> or <code>Professor</code> the same way, while each decides how to receive it, keeping the system flexible as it grows.</p> <p>Think of the four pillars as four levers that keep a growing codebase simple without dumbing it down. </p> <p>Encapsulation wraps data together with the rules that keep it valid, so changes happen in one safe place instead of leaking across files. Abstraction gives a clean surface to the outside world, so callers talk in the language of the problem while the moving parts stay hidden and free to improve. </p> <p>Inheritance collects what\u2019s truly shared into a common type, so specialization adds details instead of copying the same code again. Polymorphism lets different kinds of things respond to the same request in their own way, so new cases fit without rewriting the caller. </p> <p>Used together, these ideas reduce coupling, make intent obvious, and keep feature work focused where it belongs.</p>"},{"location":"01-fundamentals/intro-oop/#things-to-remember","title":"Things to remember","text":"<ul> <li>Think in objects, not steps: identify the main things in the problem and what each is responsible for.</li> <li>Keep data with its rules: put the logic that protects or updates data next to the data itself.</li> <li>Show a simple surface: expose clear methods for what something does; hide how it does it.</li> <li>Keep changes local: design so new features or policies touch only the objects that own those rules.</li> </ul>"},{"location":"01-fundamentals/intro-oop/#further-learning","title":"Further learning","text":"<ul> <li>These ideas can be tricky at first. To go deeper, explore beginner-friendly tutorials that walk through classes, objects, and the four pillars step by step.</li> <li>Prefer video? Try a short OOP walkthrough for newcomers that illustrates concepts with clear examples.</li> <li>Want practice? Pick a hands-on guide with small projects to apply encapsulation, inheritance, abstraction, and polymorphism right away.</li> </ul>"},{"location":"01-fundamentals/thinking-objects/","title":"Thinking in Objects: Design Principles and Refactoring","text":""},{"location":"01-fundamentals/thinking-objects/#introduction-when-working-code-isnt-enough","title":"Introduction - When Working Code Isn't Enough","text":"<p>Last week you built a functional banking system where customers managed multiple accounts using <code>ArrayList</code>. The code worked perfectly: customers could open accounts, deposit money, withdraw funds, and track total balances. But as you stared at the <code>Customer</code> class, something felt wrong.</p> <p>Consider what happens when a customer wants to transfer money to another customer's account. Your current design can't handle this naturally. The <code>Customer</code> class would need to know about other customers, search through another customer's accounts, and coordinate the withdrawal-deposit sequence. This violates a fundamental principle</p> <p>objects should have one clear responsibility.</p> <p>The problem runs deeper. Your <code>Customer</code> class is juggling three distinct jobs: managing personal information (name, age, address), organizing the customer's account collection, and executing financial operations (deposits, withdrawals). Change any of these requirements and you risk breaking the others. The class has too many reasons to change - the classic sign of poor design.</p> <p>This tutorial refactors your banking system using design principles that separate concerns cleanly. You'll learn the Single Responsibility Principle through practical refactoring, discover why immutable objects prevent bugs, and understand when to use <code>enums</code> instead of primitive types. Most importantly, you'll see how introducing new classes (Transaction and Bank) makes the system easier to understand, test, and extend.</p>"},{"location":"01-fundamentals/thinking-objects/#three-jobs-in-one-class","title":"Three Jobs in One Class","text":"<p>Look at the responsibilities hidden in your current <code>Customer</code> implementation:</p> <pre><code>public class Customer {\n    // Job 1: Store personal information\n    private int id;\n    private String name;\n    private int age;\n    private String address;\n\n    // Job 2: Manage account collection\n    private ArrayList&lt;Account&gt; accounts;\n\n    // Job 3: Execute financial operations\n    public boolean deposit(int accountId, double amount) { ... }\n    public boolean withdraw(int accountId, double amount) { ... }\n}\n</code></pre> <p>Each job represents a different reason to change. If customer information requirements change (add email, phone number), you touch this class. If account management rules change (limit number of accounts, add account types), you touch this class. If transaction processing changes (add validation, logging, security checks), you touch this class again.</p>"},{"location":"01-fundamentals/thinking-objects/#the-transfer-money-problem","title":"The Transfer Money Problem","text":"<p>The design breaks down completely when you try to implement transfers between customers:</p> <pre><code>// How would you implement this?\npublic boolean transferTo(Customer otherCustomer, int fromAccountId, \n                          int toAccountId, double amount) {\n    // Customer would need to access another customer's accounts\n    // Who coordinates the withdrawal and deposit?\n    // What if withdrawal succeeds but deposit fails?\n    // This doesn't feel right...\n}\n</code></pre> <p>There's no good place to put this method. If you put it in <code>Customer</code>, then customers know about other customers' internal structure. If you put it in <code>Account</code>, accounts would need to know about other accounts and customers. The design is fighting you because the responsibilities are tangled.</p>"},{"location":"01-fundamentals/thinking-objects/#single-responsibility-principle-srp","title":"Single Responsibility Principle (SRP)","text":"<p>The Single Responsibility Principle states: A class should have only one reason to change.</p> <p>When a class has multiple responsibilities, changes to one responsibility affect code handling the others. Testing becomes difficult because you can't test account management without also setting up transaction processing. Understanding the class requires learning everything it does instead of focusing on one clear purpose.</p> <p>The solution is separation of concerns: split the responsibilities across multiple focused classes, each with a single, well-defined job.</p>"},{"location":"01-fundamentals/thinking-objects/#introducing-the-transaction-class","title":"Introducing the Transaction Class","text":"<p>Before refactoring <code>Customer</code>, we need a new concept: the transaction itself. Real banks don't just move money around. Instead, they create permanent records of every operation. Your system needs the same capability.</p>"},{"location":"01-fundamentals/thinking-objects/#why-transactions-need-their-own-class","title":"Why Transactions Need Their Own Class","text":"<p>Currently, when you deposit money, this happens:</p> <pre><code>// Version 2 approach\npublic boolean deposit(int accountId, double amount) {\n    Account account = findAccount(accountId);\n    if (account != null) {\n        return account.deposit(amount);  // Money moves, but no record kept\n    }\n    return false;\n}\n</code></pre> <p>Money moves, the balance updates, but no history exists. If a customer disputes a charge, or you need to audit accounts, or the system crashes mid-transaction, you have no record of what happened. Professional banking systems maintain complete audit trails.</p> <p>A transaction is a value object; it represents data that describes a specific event. Once created, it never changes.</p>"},{"location":"01-fundamentals/thinking-objects/#understanding-immutability","title":"Understanding Immutability","text":"<p>Immutable objects cannot be modified after creation. Every field is <code>final</code>, and there are no setter methods. For transactions, immutability is crucial:</p> <pre><code>public class Transaction {\n    // All fields are final - cannot be changed after construction\n    private final int transactionId;\n    private final TransactionType type;\n    private final double amount;\n    private final int accountId;\n    private final LocalDateTime timestamp;\n    private final double balanceAfter;\n    private final String description;\n\n    // Constructor sets values once\n    // No setters exist\n}\n</code></pre> <p>Why does this matter? Imagine if transactions were mutable. Someone could accidentally change the amount on a past transaction, alter timestamps to hide activity, or modify balances after the fact. Immutability makes these bugs impossible. Once a transaction record is created, it's frozen forever.</p> <p>Thread safety is another benefit. When multiple parts of your program access the same transaction object, you don't need locks or synchronization because nobody can change it. The object is safe by design.</p>"},{"location":"01-fundamentals/thinking-objects/#enums-for-type-safety","title":"Enums for Type Safety","text":"<p>Before creating the Transaction class, we need to solve the \"magic string\" problem. Look at how you might track transaction types with strings:</p> <pre><code>// Fragile approach - typos become runtime bugs\nString type = \"DEPOSIT\";    // Works\nString type2 = \"deposit\";   // Different string!\nString type3 = \"DEPOSITT\";  // Typo - no compile error\n</code></pre> <p>Strings are dangerous for representing fixed categories because the compiler can't help you. Typos slip through, and comparisons become error-prone. Enums solve this by defining a fixed set of possible values:</p> <pre><code>/**\n * Enum representing types of banking transactions.\n */\npublic enum TransactionType {\n    DEPOSIT,\n    WITHDRAW,\n    TRANSFER_IN,\n    TRANSFER_OUT\n}\n</code></pre> <p>Now you can only use these four values. The IDE autocompletes them, the compiler catches typos, and switch statements warn you if you forget a case. It's impossible to create an invalid transaction type.</p>"},{"location":"01-fundamentals/thinking-objects/#building-the-transaction-class","title":"Building the Transaction Class","text":"<p>Here's the complete Transaction class with automatic ID generation:</p> <pre><code>import java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\n\npublic class Transaction {\n    /** Enum to define types of transactions */\n    public enum TransactionType {\n        DEPOSIT, WITHDRAW, TRANSFER_IN, TRANSFER_OUT\n    }\n\n    /** Static counter for generating unique transaction IDs */\n    private static int transactionCounter = 10000;\n\n    private final int transactionId;\n    private final TransactionType type;\n    private final double amount;\n    private final int accountId;\n    private final int relatedAccountId;  // For transfers\n    private final LocalDateTime timestamp;\n    private final double balanceAfter;\n    private final String description;\n\n    private static final DateTimeFormatter FORMATTER = \n        DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n\n    /**\n     * Constructs a transaction for deposits and withdrawals.\n     */\n    public Transaction(TransactionType type, double amount, int accountId, \n                      double balanceAfter, String description) {\n        this.transactionId = ++transactionCounter;\n        this.type = type;\n        this.amount = amount;\n        this.accountId = accountId;\n        this.relatedAccountId = -1;\n        this.timestamp = LocalDateTime.now();\n        this.balanceAfter = balanceAfter;\n        this.description = description;\n    }\n\n    /**\n     * Constructs a transfer transaction with related account.\n     */\n    public Transaction(TransactionType type, double amount, int accountId,\n                      int relatedAccountId, double balanceAfter, String description) {\n        this.transactionId = ++transactionCounter;\n        this.type = type;\n        this.amount = amount;\n        this.accountId = accountId;\n        this.relatedAccountId = relatedAccountId;\n        this.timestamp = LocalDateTime.now();\n        this.balanceAfter = balanceAfter;\n        this.description = description;\n    }\n\n    // Getters only - no setters because immutable\n    public int getTransactionId() { return transactionId; }\n    public TransactionType getType() { return type; }\n    public double getAmount() { return amount; }\n    public int getAccountId() { return accountId; }\n    public int getRelatedAccountId() { return relatedAccountId; }\n    public LocalDateTime getTimestamp() { return timestamp; }\n    public double getBalanceAfter() { return balanceAfter; }\n    public String getDescription() { return description; }\n\n    @Override\n    public String toString() {\n        String relatedInfo = (relatedAccountId != -1) \n            ? \", relatedAccount=\" + relatedAccountId \n            : \"\";\n\n        return String.format(\"Transaction{id=%d, type=%s, amount=\u20ac%.2f, account=%d%s, \" +\n                           \"balanceAfter=\u20ac%.2f, time=%s, desc='%s'}\",\n                           transactionId, type, amount, accountId, relatedInfo,\n                           balanceAfter, timestamp.format(FORMATTER), description);\n    }\n}\n</code></pre> <p>Notice the design patterns at work:</p> <ul> <li>Constructor overloading: Two constructors handle different transaction types. Regular deposits/withdrawals don't need a related account ID, but transfers do.</li> <li>Automatic ID generation: The static counter ensures every transaction gets a unique ID, just like you did with Account IDs.</li> <li>LocalDateTime: Java's modern date-time API provides immutable timestamps that are thread-safe and easy to format.</li> <li>No setters: The absence of setter methods makes immutability explicit. Once constructed, the transaction is frozen.</li> </ul>"},{"location":"01-fundamentals/thinking-objects/#adding-transaction-history-to-account","title":"Adding Transaction History to Account","text":"<p>Now that transactions exist as objects, Account can maintain a history:</p> <pre><code>import java.util.ArrayList;\n\npublic class Account {\n    // Existing fields\n    private static int accountCounter = 1000;\n    private final int accountId;\n    private double balance;\n    private boolean isFrozen;\n\n    // NEW: Transaction history\n    private ArrayList&lt;Transaction&gt; transactionHistory;\n\n    public Account() {\n        this.accountId = ++accountCounter;\n        this.balance = 0.0;\n        this.isFrozen = false;\n        this.transactionHistory = new ArrayList&lt;&gt;();  // Initialize empty list\n    }\n\n    public Account(double initialBalance) {\n        if (initialBalance &lt; 0) {\n            throw new IllegalArgumentException(\"Initial balance cannot be negative\");\n        }\n        this.accountId = ++accountCounter;\n        this.balance = initialBalance;\n        this.isFrozen = false;\n        this.transactionHistory = new ArrayList&lt;&gt;();\n\n        // Record initial deposit as first transaction\n        if (initialBalance &gt; 0) {\n            Transaction initialDeposit = new Transaction(\n                Transaction.TransactionType.DEPOSIT,\n                initialBalance,\n                accountId,\n                balance,\n                \"Initial deposit\"\n            );\n            transactionHistory.add(initialDeposit);\n        }\n    }\n}\n</code></pre> <p>Now every operation creates a transaction record. Update the deposit method:</p> <pre><code>public boolean deposit(double amount) {\n    if (isFrozen) {\n        System.out.println(\"Cannot deposit. Account #\" + accountId + \" is frozen.\");\n        return false;\n    }\n\n    if (amount &gt; 0) {\n        balance += amount;\n\n        // Create and store transaction record\n        Transaction transaction = new Transaction(\n            Transaction.TransactionType.DEPOSIT,\n            amount,\n            accountId,\n            balance,\n            \"Deposit\"\n        );\n        transactionHistory.add(transaction);\n\n        System.out.println(\"Deposited: \u20ac\" + amount + \" to Account #\" + accountId);\n        return true;\n    } else {\n        System.out.println(\"Deposit amount must be positive.\");\n        return false;\n    }\n}\n</code></pre> <p>The withdrawal method follows the same pattern\u2014update balance, create transaction, add to history. Now you have a complete audit trail.</p>"},{"location":"01-fundamentals/thinking-objects/#defensive-copying-with-collections","title":"Defensive Copying with Collections","text":"<p>When exposing the transaction history, you need to prevent external code from modifying it:</p> <pre><code>import java.util.Collections;\nimport java.util.List;\n\n/**\n * Returns an unmodifiable view of the transaction history.\n */\npublic List&lt;Transaction&gt; getTransactionHistory() {\n    return Collections.unmodifiableList(transactionHistory);\n}\n</code></pre> <p>This returns a read-only view. External code can iterate through transactions and read data, but cannot add, remove, or modify transactions. Your internal list stays protected.</p>"},{"location":"01-fundamentals/thinking-objects/#why-this-design-works","title":"Why This Design Works","text":"<ul> <li>Immutability prevents bugs: Transaction records cannot be accidentally corrupted after creation.</li> <li>Enums catch errors early: Type-safe constants mean typos become compile errors, not runtime failures.</li> <li>Complete audit trail: Every operation leaves a permanent, timestamped record for compliance and debugging.</li> <li>Encapsulation maintained: The unmodifiable list prevents external manipulation while allowing inspection.</li> </ul> <p>Transaction is a perfect example of a value object: it represents data, doesn't change, and has no complex behavior beyond describing itself.</p>"},{"location":"01-fundamentals/thinking-objects/#introducing-the-bank-class","title":"Introducing the Bank Class","text":"<p>With transactions tracking operations, the next step addresses the core design flaw: <code>Customer</code> doing too many things. The solution is a new class that coordinates operations between customers\u2014a Bank.</p>"},{"location":"01-fundamentals/thinking-objects/#the-coordination-problem","title":"The Coordination Problem","text":"<p>Remember the transfer problem? Here's why it needs a dedicated coordinator:</p> <pre><code>// Customer can't naturally handle this\ncustomer1.transferTo(customer2, account1Id, account2Id, 500.0);\n\n// This requires:\n// 1. Access to customer2's internal account list\n// 2. Coordinating withdrawal from customer1's account\n// 3. Coordinating deposit to customer2's account\n// 4. Handling the case where withdrawal works but deposit fails\n</code></pre> <p>Customer shouldn't know about other customers' internals. That would create tight coupling where every customer depends on the implementation details of every other customer. Instead, we need a manager class that sits above individual customers and coordinates interactions.</p>"},{"location":"01-fundamentals/thinking-objects/#single-responsibility-applied","title":"Single Responsibility Applied","text":"<p>The Bank class takes on exactly one responsibility: managing customers and coordinating operations between them. It doesn't store personal customer data (that's Customer's job), doesn't track account balances (that's Account's job), and doesn't create transaction records (Account handles that). It just orchestrates.</p> <pre><code>import java.util.ArrayList;\n\npublic class Bank {\n    private String bankName;\n    private ArrayList&lt;Customer&gt; customers;\n\n    public Bank(String bankName) {\n        this.bankName = bankName;\n        this.customers = new ArrayList&lt;&gt;();\n    }\n\n    public String getBankName() {\n        return bankName;\n    }\n}\n</code></pre> <p>The structure mirrors Customer's relationship with Account: Bank has a collection of Customers, just like Customer has a collection of Accounts. This creates a clean three-level hierarchy: Bank \u2192 Customer \u2192 Account.</p>"},{"location":"01-fundamentals/thinking-objects/#customer-management-operations","title":"Customer Management Operations","text":"<p>Bank needs methods to add, remove, and find customers:</p> <pre><code>/**\n * Adds a new customer to the bank.\n */\npublic boolean addCustomer(Customer customer) {\n    if (customer == null) {\n        System.out.println(\"Cannot add null customer\");\n        return false;\n    }\n\n    if (findCustomer(customer.getId()) != null) {\n        System.out.println(\"Customer with ID \" + customer.getId() + \" already exists.\");\n        return false;\n    }\n\n    customers.add(customer);\n    System.out.println(\"Customer \" + customer.getName() + \" (ID: \" + customer.getId() + \n                     \") added to \" + bankName);\n    return true;\n}\n\n/**\n * Finds a customer by their ID.\n */\npublic Customer findCustomer(int customerId) {\n    for (Customer customer : customers) {\n        if (customer.getId() == customerId) {\n            return customer;\n        }\n    }\n    return null;\n}\n\n/**\n * Removes a customer from the bank.\n */\npublic boolean removeCustomer(int customerId) {\n    Customer customer = findCustomer(customerId);\n    if (customer == null) {\n        System.out.println(\"Customer with ID \" + customerId + \" not found.\");\n        return false;\n    }\n\n    customers.remove(customer);\n    System.out.println(\"Customer \" + customer.getName() + \" removed from \" + bankName);\n    return true;\n}\n</code></pre> <p>This follows the same pattern you used in Customer for managing accounts: search, validate, then act. The Bank is a collection manager one level up in the hierarchy.</p>"},{"location":"01-fundamentals/thinking-objects/#delegating-financial-operations","title":"Delegating Financial Operations","text":"<p>Here's where Bank's coordination role becomes clear. When someone deposits money, Bank doesn't handle the money\u2014it routes the operation to the right account:</p> <pre><code>/**\n * Deposits money into a specific customer's account.\n */\npublic boolean deposit(int customerId, int accountId, double amount) {\n    Customer customer = findCustomer(customerId);\n    if (customer == null) {\n        System.out.println(\"Customer with ID \" + customerId + \" not found.\");\n        return false;\n    }\n\n    Account account = customer.findAccount(accountId);\n    if (account == null) {\n        System.out.println(\"Account #\" + accountId + \" not found for customer \" + customer.getName());\n        return false;\n    }\n\n    return account.deposit(amount);  // Delegate to Account\n}\n</code></pre> <p>Bank knows nothing about balance validation, freeze checks, or transaction recording; that's Account's job. Bank just ensures the request reaches the right account.</p> <p>Withdrawal follows the identical pattern:</p> <pre><code>/**\n * Withdraws money from a specific customer's account.\n */\npublic boolean withdraw(int customerId, int accountId, double amount) {\n    Customer customer = findCustomer(customerId);\n    if (customer == null) {\n        System.out.println(\"Customer with ID \" + customerId + \" not found.\");\n        return false;\n    }\n\n    Account account = customer.findAccount(accountId);\n    if (account == null) {\n        System.out.println(\"Account #\" + accountId + \" not found for customer \" + customer.getName());\n        return false;\n    }\n\n    return account.withdraw(amount);\n}\n</code></pre> <p>This is delegation: Bank coordinates access but doesn't duplicate the business logic. Each class stays focused on its own responsibility.</p>"},{"location":"01-fundamentals/thinking-objects/#the-transfer-operation","title":"The Transfer Operation","text":"<p>Now we can solve the transfer problem properly:</p> <pre><code>/**\n * Transfers money between two accounts (can be different customers).\n */\npublic boolean transfer(int fromCustomerId, int fromAccountId, \n                       int toCustomerId, int toAccountId, double amount) {\n\n    // Find source customer and account\n    Customer fromCustomer = findCustomer(fromCustomerId);\n    if (fromCustomer == null) {\n        System.out.println(\"Source customer with ID \" + fromCustomerId + \" not found.\");\n        return false;\n    }\n\n    Account fromAccount = fromCustomer.findAccount(fromAccountId);\n    if (fromAccount == null) {\n        System.out.println(\"Source account #\" + fromAccountId + \" not found.\");\n        return false;\n    }\n\n    // Find destination customer and account\n    Customer toCustomer = findCustomer(toCustomerId);\n    if (toCustomer == null) {\n        System.out.println(\"Destination customer with ID \" + toCustomerId + \" not found.\");\n        return false;\n    }\n\n    Account toAccount = toCustomer.findAccount(toAccountId);\n    if (toAccount == null) {\n        System.out.println(\"Destination account #\" + toAccountId + \" not found.\");\n        return false;\n    }\n\n    // Validate transfer conditions\n    if (amount &lt;= 0) {\n        System.out.println(\"Transfer amount must be positive.\");\n        return false;\n    }\n\n    if (fromAccount.isFrozen() || toAccount.isFrozen()) {\n        System.out.println(\"Cannot transfer: one or both accounts are frozen.\");\n        return false;\n    }\n\n    if (fromAccount.getBalance() &lt; amount) {\n        System.out.println(\"Insufficient funds in source account.\");\n        return false;\n    }\n\n    // Execute the transfer atomically\n    if (fromAccount.transferOut(amount, toAccountId) &amp;&amp; \n        toAccount.transferIn(amount, fromAccountId)) {\n        System.out.println(\"Transfer successful: \u20ac\" + amount + \" from Account #\" + \n                         fromAccountId + \" to Account #\" + toAccountId);\n        return true;\n    }\n\n    return false;\n}\n</code></pre> <p>Bank is the only class with visibility into both customers and their accounts, making it the natural coordinator for transfers. The method validates everything up front, then executes the transfer as an atomic operation through special package-private methods in Account:</p> <pre><code>// Add these to Account class\nboolean transferOut(double amount, int toAccountId) {\n    if (isFrozen || amount &lt;= 0 || amount &gt; balance) {\n        return false;\n    }\n\n    balance -= amount;\n    Transaction transaction = new Transaction(\n        Transaction.TransactionType.TRANSFER_OUT,\n        amount,\n        accountId,\n        toAccountId,\n        balance,\n        \"Transfer to account #\" + toAccountId\n    );\n    transactionHistory.add(transaction);\n    return true;\n}\n\nboolean transferIn(double amount, int fromAccountId) {\n    if (isFrozen || amount &lt;= 0) {\n        return false;\n    }\n\n    balance += amount;\n    Transaction transaction = new Transaction(\n        Transaction.TransactionType.TRANSFER_IN,\n        amount,\n        accountId,\n        fromAccountId,\n        balance,\n        \"Transfer from account #\" + fromAccountId\n    );\n    transactionHistory.add(transaction);\n    return true;\n}\n</code></pre> <p>These methods are package-private (no access modifier) so only classes in the same package\u2014like Bank\u2014can call them. They're not part of Account's public API because external code shouldn't call them directly; only the coordinated Bank.transfer() method should.</p>"},{"location":"01-fundamentals/thinking-objects/#why-this-design-works_1","title":"Why This Design Works","text":"<ul> <li>Clear hierarchy: Bank manages Customers, Customers manage Accounts, Accounts manage Transactions.</li> <li>Single responsibility: Bank coordinates, Customer organizes, Account executes financial logic.</li> <li>Proper delegation: Each method finds the right object and delegates the actual work to it.</li> <li>Natural fit: The design mirrors real banking where banks coordinate between customers.</li> </ul> <p>Bank doesn't bloat with unrelated functionality because it has exactly one job: coordinate operations across customers. When you need to add bank-level features like reports, interest processing, or multi-account operations, there's an obvious place for them.</p>"},{"location":"01-fundamentals/thinking-objects/#refactoring-the-customer-class","title":"Refactoring the Customer Class","text":"<p>With Bank handling coordination, Customer can focus solely on managing its own accounts. Several methods need to move or change, demonstrating how refactoring maintains functionality while improving structure.</p>"},{"location":"01-fundamentals/thinking-objects/#what-moves-to-bank","title":"What Moves to Bank","text":"<p>The deposit and withdraw methods that took customer and account IDs? Those move to Bank because they require coordination:</p> <pre><code>// REMOVE these from Customer:\npublic boolean deposit(int accountId, double amount) { ... }\npublic boolean withdraw(int accountId, double amount) { ... }\n\n// They now live in Bank as:\npublic boolean deposit(int customerId, int accountId, double amount) { ... }\npublic boolean withdraw(int customerId, int accountId, double amount) { ... }\n</code></pre> <p>This makes sense: Bank knows which customer to route the request to, while Customer shouldn't need external customer IDs in its method signatures.</p>"},{"location":"01-fundamentals/thinking-objects/#what-stays-in-customer","title":"What Stays in Customer","text":"<p>Everything related to managing the customer's own account collection remains:</p> <pre><code>public class Customer {\n    private final int id;\n    private String name;\n    private int age;\n    private String address;\n    private ArrayList&lt;Account&gt; accounts;\n\n    // These stay - managing own accounts\n    public boolean addAccount(Account account) { ... }\n    public boolean removeAccount(Account account) { ... }\n    public Account findAccount(int accountId) { ... }\n    public int getAccountCount() { ... }\n    public double getTotalBalance() { ... }\n    public void displayAllAccounts() { ... }\n}\n</code></pre> <p>Customer's job is clear now: manage personal information and the account collection. No financial operations, no knowledge of other customers\u2014just focused account management.</p>"},{"location":"01-fundamentals/thinking-objects/#making-customer-id-immutable","title":"Making Customer ID Immutable","text":"<p>One subtle but important change: the customer ID should never change after creation, so make it <code>final</code>:</p> <pre><code>public class Customer {\n    private final int id;  // Cannot be changed after construction\n\n    public Customer(int id, String name, int age, String address) {\n        this.id = id;\n        // ...\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    // NO setId() method - ID is permanent\n}\n</code></pre> <p>This prevents bugs where IDs accidentally change, breaking the Bank's ability to find customers. Immutability for identity fields is a best practice.</p>"},{"location":"01-fundamentals/thinking-objects/#understanding-equals-and-hashcode","title":"Understanding equals() and hashCode()","text":"<p>With objects now representing customers, accounts, and transactions, you need to understand how Java determines if two objects are \"the same.\" This becomes critical when searching collections or preventing duplicate customers.</p>"},{"location":"01-fundamentals/thinking-objects/#the-default-equality-problem","title":"The Default Equality Problem","text":"<p>Without custom equals(), Java compares memory addresses:</p> <pre><code>Customer ada1 = new Customer(1815, \"Ada Lovelace\", 36, \"London\");\nCustomer ada2 = new Customer(1815, \"Ada Lovelace\", 36, \"London\");\n\nSystem.out.println(ada1 == ada2);  // false - different objects in memory\nSystem.out.println(ada1.equals(ada2));  // false - default equals uses ==\n</code></pre> <p>Even though both customers have the same ID and data, Java sees them as different because they occupy different memory locations. For banking, this is wrong\u2014two customers with the same ID should be considered the same customer regardless of memory location.</p>"},{"location":"01-fundamentals/thinking-objects/#overriding-equals-for-meaningful-equality","title":"Overriding equals() for Meaningful Equality","text":"<p>Add this to Customer:</p> <pre><code>import java.util.Objects;\n\n@Override\npublic boolean equals(Object obj) {\n    // Same reference? Definitely equal\n    if (this == obj) return true;\n\n    // Null or different class? Not equal\n    if (obj == null || getClass() != obj.getClass()) return false;\n\n    // Cast and compare ID\n    Customer customer = (Customer) obj;\n    return id == customer.id;\n}\n</code></pre> <p>This implements identity-based equality: two customers are equal if they have the same ID, regardless of name, age, or address. The ID is the unique identifier, so that's what matters for equality.</p> <p>The method follows a standard pattern:</p> <ol> <li>Reference check: If it's literally the same object, return true immediately.</li> <li>Null/class check: Ensure we're comparing with another Customer object.</li> <li>Field comparison: Compare the identifying field(s)\u2014in this case, just the ID.</li> </ol>"},{"location":"01-fundamentals/thinking-objects/#the-hashcode-contract","title":"The hashCode() Contract","text":"<p>Whenever you override equals(), you must override hashCode():</p> <pre><code>@Override\npublic int hashCode() {\n    return Objects.hash(id);\n}\n</code></pre> <p>This is Java's fundamental rule: objects that are equal must have the same hash code. If two customers have the same ID (and are therefore equal), they must return the same hash code.</p> <p>Why? Hash-based collections like HashMap and HashSet use hash codes to organize objects. If equal objects have different hash codes, the collections break. You might put a customer in a HashSet, then later search for an equal customer and not find it because the hash codes differ.</p> <p>The <code>Objects.hash()</code> utility method generates a hash code from the fields you pass it. Use the same fields you compared in equals()\u2014for Customer, that's just the ID.</p>"},{"location":"01-fundamentals/thinking-objects/#adding-equals-and-hashcode-to-account","title":"Adding equals() and hashCode() to Account","text":"<p>Account needs the same treatment:</p> <pre><code>public class Account {\n    private final int accountId;\n    // ...\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        Account account = (Account) obj;\n        return accountId == account.accountId;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(accountId);\n    }\n}\n</code></pre> <p>Two accounts are equal if they have the same account ID. Balance, freeze status, and transaction history don't matter for identity\u2014those are changeable state, not identity.</p>"},{"location":"01-fundamentals/thinking-objects/#why-this-matters","title":"Why This Matters","text":"<ul> <li>Searching works correctly: When Bank searches for a customer by creating a temporary Customer object with matching ID, equals() ensures it finds the right one.</li> <li>Collections work properly: HashSet won't allow duplicate customers with the same ID.</li> <li>Comparisons make sense: Business logic comparing customers compares identity, not memory addresses.</li> </ul>"},{"location":"01-fundamentals/thinking-objects/#putting-it-all-together","title":"Putting It All Together","text":"<p>With all pieces in place, here's how the refactored system works in practice. This demonstrates the interplay between Bank, Customer, Account, and Transaction.</p>"},{"location":"01-fundamentals/thinking-objects/#creating-the-bank-and-customers","title":"Creating the Bank and Customers","text":"<pre><code>public class Main {\n    public static void main(String[] args) {\n        // Create the bank\n        Bank turingBank = new Bank(\"Turing National Bank\");\n\n        // Create customers\n        Customer ada = new Customer(1815, \"Ada Lovelace\", 36, \"10 St. James Square, London\");\n        Customer alan = new Customer(1912, \"Alan Turing\", 41, \"Sherborne School, Dorset\");\n\n        // Add customers to bank\n        turingBank.addCustomer(ada);\n        turingBank.addCustomer(alan);\n    }\n}\n</code></pre> <p>Output: <pre><code>Customer Ada Lovelace (ID: 1815) added to Turing National Bank\nCustomer Alan Turing (ID: 1912) added to Turing National Bank\n</code></pre></p>"},{"location":"01-fundamentals/thinking-objects/#opening-accounts","title":"Opening Accounts","text":"<pre><code>// Create accounts\nAccount adaSavings = new Account(5000.0);\nAccount adaChecking = new Account(2000.0);\n\n// Add to customer\nada.addAccount(adaSavings);\nada.addAccount(adaChecking);\n\n// Alan's accounts\nAccount alanSavings = new Account(3000.0);\nAccount alanChecking = new Account(1500.0);\n\nalan.addAccount(alanSavings);\nalan.addAccount(alanChecking);\n</code></pre> <p>Output: <pre><code>Account #1001 added to customer Ada Lovelace\nAccount #1002 added to customer Ada Lovelace\nAccount #1003 added to customer Alan Turing\nAccount #1004 added to customer Alan Turing\n</code></pre></p> <p>Notice the automatic ID generation\u2014accounts get sequential IDs without any manual coordination.</p>"},{"location":"01-fundamentals/thinking-objects/#performing-transactions-through-bank","title":"Performing Transactions Through Bank","text":"<pre><code>// Deposit to Ada's savings\nturingBank.deposit(1815, 1001, 1000.0);\n\n// Withdraw from Alan's checking\nturingBank.withdraw(1912, 1004, 200.0);\n\n// Transfer from Ada to Alan\nturingBank.transfer(1815, 1001, 1912, 1003, 750.0);\n</code></pre> <p>Output: <pre><code>Deposited: \u20ac1000.0 to Account #1001\nWithdrawn: \u20ac200.0 from Account #1004\nTransfer successful: \u20ac750.0 from Account #1001 to Account #1003\n</code></pre></p> <p>Each operation creates transaction records automatically. Bank coordinates, Account executes and records.</p>"},{"location":"01-fundamentals/thinking-objects/#viewing-transaction-history","title":"Viewing Transaction History","text":"<pre><code>Account adaSavingsAccount = ada.findAccount(1001);\nfor (Transaction t : adaSavingsAccount.getTransactionHistory()) {\n    System.out.println(t);\n}\n</code></pre> <p>Output: <pre><code>Transaction{id=10001, type=DEPOSIT, amount=\u20ac5000.00, account=1001, balanceAfter=\u20ac5000.00, time=2024-10-24 20:15:03, desc='Initial deposit'}\nTransaction{id=10002, type=DEPOSIT, amount=\u20ac1000.00, account=1001, balanceAfter=\u20ac6000.00, time=2024-10-24 20:15:05, desc='Deposit'}\nTransaction{id=10003, type=TRANSFER_OUT, amount=\u20ac750.00, account=1001, relatedAccount=1003, balanceAfter=\u20ac5250.00, time=2024-10-24 20:15:07, desc='Transfer to account #1003'}\n</code></pre></p> <p>Complete audit trail with timestamps, transaction IDs, and balance after each operation. Immutable records that can't be tampered with.</p>"},{"location":"01-fundamentals/thinking-objects/#testing-equals-and-hashcode","title":"Testing equals() and hashCode()","text":"<pre><code>// Create duplicate customer with same ID\nCustomer ada2 = new Customer(1815, \"Ada Lovelace\", 36, \"Different Address\");\n\nSystem.out.println(ada.equals(ada2));  // true - same ID\nSystem.out.println(ada.hashCode() == ada2.hashCode());  // true - required by contract\n\n// Bank prevents duplicate\nturingBank.addCustomer(ada2);  // \"Customer with ID 1815 already exists.\"\n</code></pre> <p>The equals() method ensures the Bank correctly identifies the duplicate customer despite different object references.</p>"},{"location":"01-fundamentals/thinking-objects/#summary","title":"Summary","text":"<p>You've transformed a functional banking system into one built on solid design principles. The changes touched every class but preserved all functionality while dramatically improving structure.</p>"},{"location":"01-fundamentals/thinking-objects/#key-concepts-mastered","title":"Key Concepts Mastered","text":""},{"location":"01-fundamentals/thinking-objects/#single-responsibility-principle","title":"Single Responsibility Principle","text":"<p>Each class has one clear job. Customer manages its accounts, Account tracks its balance and transactions, Bank coordinates between customers. When requirements change, you know exactly which class to modify.</p>"},{"location":"01-fundamentals/thinking-objects/#immutability-for-safety","title":"Immutability for safety","text":"<p><code>Transaction</code> objects cannot change after creation. This prevents bugs, enables thread-safety, and maintains audit trail integrity. Immutability is a best practice for value objects representing data.</p>"},{"location":"01-fundamentals/thinking-objects/#enums-for-type-safety_1","title":"Enums for type safety","text":"<p><code>TransactionType enum</code> replaces error-prone strings with compiler-enforced constants. Impossible to create invalid transaction types, and IDE autocomplete guides usage.</p>"},{"location":"01-fundamentals/thinking-objects/#refactoring-without-breaking","title":"Refactoring without breaking","text":"<p>You reorganized responsibilities extensively yet all operations still work. This demonstrates that good design isn't about getting it right first time\u2014it's about recognizing problems and fixing them systematically.</p>"},{"location":"01-fundamentals/thinking-objects/#equals-and-hashcode-contract","title":"<code>equals()</code> and <code>hashCode()</code> contract","text":"<p>Custom equality based on identity fields (IDs) makes collections work correctly and comparisons meaningful. Always override both methods together, using the same fields in each.</p>"},{"location":"01-fundamentals/thinking-objects/#defensive-copying-with-collections_1","title":"Defensive copying with Collections","text":"<p>Returning unmodifiable views of internal lists prevents external manipulation while allowing inspection. This maintains encapsulation even when exposing collection data.</p>"},{"location":"01-fundamentals/thinking-objects/#object-coordination","title":"Object coordination","text":"<p>Bank demonstrates how manager classes can coordinate operations between objects without duplicating their business logic. Delegation keeps responsibilities separate.</p>"},{"location":"01-fundamentals/thinking-objects/#complete-code","title":"Complete Code","text":"<p>Find the complete working code organized by version:</p> <ul> <li>v2_basic_collections - Starting point with ArrayList and relationships</li> <li>v3_thinking_in_objects - Refactored version with Transaction, Bank, and proper design</li> </ul> <p>The same Customer and Account functionality exists, but the structure now supports growth. Next week you'll build on this foundation with inheritance and polymorphism, introducing different account types (savings, checking) that share common behavior while implementing specialized rules. The clean design makes that extension natural instead of painful.</p>"},{"location":"02-core-oop/","title":"Core OOP Principles Overview","text":"<p>Master the four pillars that define object-oriented programming. Build robust, maintainable systems using inheritance, polymorphism, encapsulation, and abstraction with clear examples and practical applications.</p>"},{"location":"02-core-oop/#abstraction-and-encapsulation","title":"Abstraction and Encapsulation","text":"<p>Control access and protect data</p> <p>Master the practice of bundling data and methods while controlling access through visibility modifiers. Learn to create clean interfaces using getters, setters, and proper data hiding techniques.</p> <p>You'll learn: Access modifiers, getter/setter methods, data validation, and maintaining object integrity</p>"},{"location":"02-core-oop/#inheritance-and-polymorphism","title":"Inheritance and Polymorphism","text":"<p>Extend and specialize classes</p> <p>Learn to create class hierarchies where child classes inherit properties and methods from parent classes. Master super and subclass relationships, method overriding, and the IS-A relationship that models real-world specialization.</p> <p>One interface, many forms</p> <p>Understand how objects of different types can be treated uniformly through method overriding and dynamic binding. Write flexible code that works with multiple object types using the same interface.</p> <p>You'll learn: How to extend classes, override methods, use super keyword, and design effective class hierarchies. In addition, you will also learn method overriding, runtime polymorphism, casting objects, and designing adaptable systems</p>"},{"location":"02-core-oop/#abstract-classes-interfaces","title":"Abstract Classes &amp; Interfaces","text":"<p>Define contracts and common behavior</p> <p>Create abstract classes that provide partial implementations and interfaces that define pure contracts. Learn when to use each approach and how they enable flexible, extensible designs.</p> <p>You'll learn: Abstract classes vs interfaces, implementing contracts, multiple inheritance through interfaces, and designing flexible systems</p> <p>Start here: Begin with Inheritance to understand class relationships, then move through Polymorphism and Encapsulation. Finish with Abstract Classes &amp; Interfaces to see how these principles work together. Complete the exercises after each topic to reinforce the concepts\u2014these principles build on each other.</p>"},{"location":"02-core-oop/abstract-interfaces/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"02-core-oop/encapsulation/","title":"Abstraction and Encapsulation: The Foundation of OOP","text":""},{"location":"02-core-oop/encapsulation/#introduction-hiding-what-matters","title":"Introduction - Hiding What Matters","text":"<p>Your banking system demonstrates two fundamental OOP principles that work together to create maintainable code: encapsulation (hiding data) and abstraction (hiding complexity). While often confused, they serve distinct purposes that are visible throughout your Account hierarchy.</p> <p>Consider what happens when external code tries to directly modify an account balance:</p> <pre><code>// Without encapsulation - dangerous\naccount.balance = -5000.0;  // Bypass all validation!\n\n// With encapsulation - safe\naccount.withdraw(100.0);  // Goes through validation\n</code></pre> <p>Encapsulation prevents the first scenario. Abstraction lets the Bank call <code>withdraw()</code> without knowing whether it's a SavingsAccount checking minimum balance or a CheckingAccount allowing overdraft.</p>"},{"location":"02-core-oop/encapsulation/#encapsulation-hiding-data","title":"Encapsulation: Hiding Data","text":"<p>Encapsulation bundles data with the methods that operate on it, and restricts direct access to internal state. External code interacts through a controlled public interface.</p>"},{"location":"02-core-oop/encapsulation/#private-fields-with-controlled-access","title":"Private Fields with Controlled Access","text":"<p>Your Account class demonstrates encapsulation fundamentals:</p> <pre><code>public class Account {\n    private final int accountId;      // Immutable - no setter\n    protected double balance;         // Protected for subclass access\n    private boolean isFrozen;         // Private - controlled access\n\n    // Controlled access through methods\n    public double getBalance() {\n        return balance;\n    }\n\n    public boolean deposit(double amount) {\n        if (amount &lt;= 0) {\n            System.out.println(\"Deposit must be positive\");\n            return false;\n        }\n        balance += amount;  // Internal modification with validation\n        return true;\n    }\n}\n</code></pre> <p>Why this matters: External code can't set <code>balance = -1000</code> or modify <code>accountId</code> after creation. All changes go through methods that validate input, creating data integrity.</p>"},{"location":"02-core-oop/encapsulation/#immutability-through-final-fields","title":"Immutability Through Final Fields","text":"<p>Transaction demonstrates a stricter form of encapsulation:</p> <pre><code>public class Transaction {\n    private final int transactionId;\n    private final TransactionType type;\n    private final double amount;\n    private final LocalDateTime timestamp;\n\n    // Constructor sets values once\n    public Transaction(TransactionType type, double amount, ...) {\n        this.transactionId = ++transactionCounter;\n        this.type = type;\n        this.amount = amount;\n        this.timestamp = LocalDateTime.now();\n    }\n\n    // Only getters - no setters\n    public double getAmount() { return amount; }\n}\n</code></pre> <p>Once created, transactions cannot be modified. This prevents audit trail tampering and eliminates a whole class of bugs.</p>"},{"location":"02-core-oop/encapsulation/#defensive-copying","title":"Defensive Copying","text":"<p>Your Account exposes transaction history safely:</p> <pre><code>public List&lt;Transaction&gt; getTransactionHistory() {\n    return Collections.unmodifiableList(transactionHistory);\n}\n</code></pre> <p>External code can read transactions but cannot add, remove, or modify them. The internal list stays protected while providing necessary access.</p>"},{"location":"02-core-oop/encapsulation/#abstraction-hiding-complexity","title":"Abstraction: Hiding Complexity","text":"<p>Abstraction hides implementation details and exposes only essential features. Users interact with simplified interfaces without needing to understand internal complexity.</p>"},{"location":"02-core-oop/encapsulation/#polymorphic-interface","title":"Polymorphic Interface","text":"<p>The Bank demonstrates abstraction by working with the <code>Account</code> interface:</p> <pre><code>public boolean withdraw(int customerId, int accountId, double amount) {\n    Account account = customer.findAccount(accountId);  // Any Account subtype\n\n    return account.withdraw(amount);  // Don't know/care which type\n}\n</code></pre> <p>The Bank doesn't know whether it's calling <code>SavingsAccount.withdraw()</code> (which checks minimum balance) or <code>CheckingAccount.withdraw()</code> (which allows overdraft). It works with the abstraction\u2014the <code>withdraw()</code> method signature\u2014not the implementation.</p>"},{"location":"02-core-oop/encapsulation/#method-overriding-hides-implementation","title":"Method Overriding Hides Implementation","text":"<p>Each account type implements <code>withdraw()</code> differently, but callers use the same interface:</p> <pre><code>// SavingsAccount - hidden complexity: minimum balance enforcement\n@Override\npublic boolean withdraw(double amount) {\n    if (balance - amount &lt; minimumBalance) {\n        System.out.println(\"Would violate minimum balance\");\n        return false;\n    }\n    return super.withdraw(amount);\n}\n\n// CheckingAccount - hidden complexity: overdraft calculation\n@Override\npublic boolean withdraw(double amount) {\n    if (amount &gt; balance + overdraftLimit) {\n        System.out.println(\"Exceeds available balance\");\n        return false;\n    }\n    balance -= amount;  // Can go negative\n    return true;\n}\n</code></pre> <p>The abstraction is the <code>withdraw()</code> method. The complexity\u2014different validation rules\u2014is hidden inside each implementation.</p>"},{"location":"02-core-oop/encapsulation/#high-level-operations","title":"High-Level Operations","text":"<p>The Bank provides abstracted operations:</p> <pre><code>turingBank.openSavingsAccount(customerId, 5000.0, 0.03);\nturingBank.applyInterestToAllSavings();\n</code></pre> <p>Users don't see the complexity: finding customers, creating accounts, iterating through account types, type checking with <code>instanceof</code>, downcasting, and calling subclass methods. The abstraction presents a simple interface to complex operations.</p>"},{"location":"02-core-oop/encapsulation/#how-they-work-together","title":"How They Work Together","text":"<p>Encapsulation secures the data. Abstraction simplifies the interface.</p> <pre><code>// Encapsulation: balance is protected, accessed through methods\nprotected double balance;\n\n// Abstraction: Account provides withdraw() interface\npublic abstract boolean withdraw(double amount);\n\n// Together: Safe data with simple usage\nAccount account = new SavingsAccount(1000.0, 0.03);\naccount.withdraw(50.0);  // Simple call, complex validation hidden\n</code></pre> <p>Your banking system uses both constantly:</p> <ul> <li>Encapsulation: Private fields, validation in methods, immutable transactions, defensive copying</li> <li>Abstraction: Polymorphic Account interface, method overriding, Bank coordinating without knowing types</li> </ul>"},{"location":"02-core-oop/encapsulation/#key-differences","title":"Key Differences","text":"Concept Purpose Implementation Example from Your Code Encapsulation Protect data Private/protected fields, public methods <code>private final int accountId</code> with only getter Abstraction Hide complexity Inheritance, interfaces, polymorphism Bank calling <code>account.withdraw()</code> without knowing type <p>Both principles create maintainable systems. Encapsulation prevents accidental data corruption. Abstraction reduces cognitive load\u2014you work with high-level concepts instead of implementation details.</p>"},{"location":"02-core-oop/exercises/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"02-core-oop/inheritance-polymorphism/","title":"Inheritance and Polymorphism: Extending Behavior Through Hierarchy","text":""},{"location":"02-core-oop/inheritance-polymorphism/#introduction-when-one-account-type-isnt-enough","title":"Introduction - When One Account Type Isn't Enough","text":"<p>In Version 3, you built a banking system where every account behaved identically. The <code>Account</code> class handled deposits, withdrawals, transaction history, and frozen status. It worked perfectly, but only for generic accounts. But real banks don't offer just one account type. They offer savings accounts with interest, checking accounts with overdraft protection, and business accounts with different fee structures.</p> <p>Consider what happens when your bank wants to add interest to savings accounts. Where would you put this functionality? You could add an <code>interestRate</code> field to <code>Account</code> and an <code>addInterest()</code> method, but then every account, that means including checking accounts that don't earn interest, would carry that unused field. You'd need boolean flags to track account types and conditional logic everywhere:</p> <pre><code>// Fragile approach with conditionals\npublic class Account {\n    private String accountType;  // \"savings\", \"checking\", etc.\n    private double interestRate;  // Only for savings\n    private double overdraftLimit;  // Only for checking\n\n    public void addInterest() {\n        if (accountType.equals(\"savings\")) {\n            // Apply interest\n        } else {\n            System.out.println(\"This account doesn't earn interest\");\n        }\n    }\n}\n</code></pre> <p>This approach fails quickly. Every new account type adds more fields and more conditionals. The <code>Account</code> class becomes bloated with special cases, testing becomes complex, and bugs multiply. When you need to change how savings accounts work, you risk breaking checking accounts because they're tangled in the same class.</p> <p>This tutorial introduces inheritance and polymorphism to model different account types cleanly. You'll learn how subclasses extend parent functionality, override methods to customize behavior, and how polymorphism lets the Bank work with any account type without knowing specifics. Most importantly, you'll see how the \"<code>is-a</code>\" relationship creates hierarchies that mirror real-world categories.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#the-account-hierarchy-problem","title":"The Account Hierarchy Problem","text":"<p>Your bank needs three account types with different rules:</p> <ol> <li>Standard Account: Basic functionality: deposits, withdrawals, transaction history (your Version 3 Account)</li> <li>Savings Account: Earns interest, requires minimum balance, can't go below minimum</li> <li>Checking Account: Allows overdraft (negative balance within limit), charges monthly fee</li> </ol> <p>These accounts share common features (balance, transactions, freeze status) but have specialized rules. </p> <p>Duplicating the common code across three separate classes creates maintenance nightmares. When you fix a bug in transaction recording, you'd need to fix it three times. When you add transaction history features, you'd implement them three times.</p> <p>Inheritance solves this by creating a hierarchy: define common functionality once in a parent class, then create specialized child classes that inherit the common behavior and add their own unique features.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#the-is-a-relationship","title":"The \"Is-A\" Relationship","text":"<p>Inheritance models the \"is-a\" relationship. </p> <p>A savings account is an account. A checking account is an account. They're specialized types of the general account concept. This contrasts with composition's \"has-a\" relationship from Version 3: a Customer has accounts, a Bank has customers.</p> <p>When thinking about inheritance, ask: \"Is this a specialized type of that?\" A <code>SavingsAccount</code> is-a specialized <code>Account</code> with extra rules. A <code>Dog</code> is-a <code>Animal</code>. A <code>Car</code> is-a <code>Vehicle</code>. If the relationship is \"is-a\", inheritance might fit. If it's \"has-a\", use composition instead.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#preparing-the-parent-class","title":"Preparing the Parent Class","text":"<p>Before creating subclasses, the <code>Account</code> class needs changes to support inheritance. Currently, subclasses can't access the fields they need to customize behavior.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#the-protected-access-modifier","title":"The Protected Access Modifier","text":"<p>Version 3's <code>Account</code> declared all fields <code>private</code>:</p> <pre><code>// Version 3 - subclasses can't access these\nprivate double balance;\nprivate ArrayList&lt;Transaction&gt; transactionHistory;\n</code></pre> <p>Private fields are invisible to subclasses. When <code>SavingsAccount</code> tries to check the balance in its overridden <code>withdraw()</code> method, it can't; <code>balance</code> is hidden by the parent. You need a middle ground between private (invisible to everyone) and public (visible to everyone).</p> <p>The <code>protected</code> modifier provides this:</p> <pre><code>// Version 4 - subclasses can access these\nprotected double balance;\nprotected ArrayList&lt;Transaction&gt; transactionHistory;\n</code></pre> <p>Protected fields are visible to:</p> <ul> <li>The class itself (like private)</li> <li>Subclasses (unlike private)</li> <li>Classes in the same package (a side effect)</li> </ul> <p>This lets <code>SavingsAccount</code> and <code>CheckingAccount</code> read and modify <code>balance</code> while keeping it hidden from external code like <code>Customer</code> or <code>Bank</code>. External code still uses <code>getBalance()</code>, but subclasses can work with the field directly when overriding behavior.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#why-not-public","title":"Why Not Public?","text":"<p>Making fields public breaks encapsulation. </p> <p>Any code anywhere could modify <code>balance</code> without validation, bypassing your carefully designed deposit/withdraw logic. Protected maintains control: only your account hierarchy can directly access the field, and you control what goes into that hierarchy.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#creating-the-savingsaccount-subclass","title":"Creating the SavingsAccount Subclass","text":"<p>The <code>SavingsAccount</code> class demonstrates the core concepts of inheritance: extending a parent class, calling parent constructors, overriding methods, and adding specialized functionality.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#declaring-the-inheritance-relationship","title":"Declaring the Inheritance Relationship","text":"<p>The <code>extends</code> keyword establishes inheritance:</p> <pre><code>public class SavingsAccount extends Account {\n    // SavingsAccount inherits all public/protected members from Account\n}\n</code></pre> <p>This single keyword gives <code>SavingsAccount</code> immediate access to all Account's public and protected methods and fields. You don't rewrite <code>deposit()</code>, <code>getBalance()</code>, <code>freeze()</code>, or transaction history management; they're inherited automatically. <code>SavingsAccount</code> starts with everything <code>Account</code> has, then adds or customizes behavior.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#adding-specialized-fields","title":"Adding Specialized Fields","text":"<p>Savings accounts need fields for their unique rules:</p> <pre><code>private double interestRate;        // Annual rate (e.g., 0.03 for 3%)\nprivate double minimumBalance;      // Minimum required balance\n\nprivate static final double DEFAULT_MINIMUM_BALANCE = 100.0;\n</code></pre> <p>These fields exist only in <code>SavingsAccount</code>. Standard accounts and checking accounts don't have them. Each subclass adds only what it needs for its specialization.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#constructor-chaining-with-super","title":"Constructor Chaining with super()","text":"<p>The constructor demonstrates how subclasses initialize inherited fields:</p> <pre><code>public SavingsAccount(double initialBalance, double interestRate) {\n    super(initialBalance);  // Call parent Account constructor\n\n    if (interestRate &lt; 0 || interestRate &gt; 1) {\n        System.out.println(\"Interest rate must be between 0 and 1\");\n    }\n\n    this.interestRate = interestRate;\n    this.minimumBalance = DEFAULT_MINIMUM_BALANCE;\n}\n</code></pre> <p>The <code>super(initialBalance)</code> call invokes the parent <code>Account</code> constructor, which sets up the account ID, balance, transaction history, and frozen status. </p> <p>This must be the first line in your constructor </p> <p>The parent must be initialized before you add subclass-specific initialization.</p> <p>After <code>super()</code> returns, the subclass constructor continues, validating and setting fields unique to savings accounts. This pattern ensures proper initialization: shared state gets set up by the parent, specialized state by the child.</p> <p>There's also an overloaded constructor accepting a custom minimum balance:</p> <pre><code>public SavingsAccount(double initialBalance, double interestRate, \n                      double minimumBalance) {\n    super(initialBalance);\n\n    if (interestRate &lt; 0 || interestRate &gt; 1) {\n        System.out.println(\"Interest rate must be between 0 and 1\");\n    }\n\n    if (minimumBalance &lt; 0) {\n        System.out.println(\"Minimum balance cannot be negative\");\n    }\n\n    this.interestRate = interestRate;\n    this.minimumBalance = minimumBalance;\n}\n</code></pre> <p>This provides flexibility: use the default minimum or specify a custom one.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#overriding-withdraw-for-specialized-behavior","title":"Overriding withdraw() for Specialized Behavior","text":"<p>The power of inheritance appears in method overriding. Savings accounts can't withdraw below the minimum balance, but the parent <code>Account.withdraw()</code> allows any withdrawal up to the balance. The solution: override <code>withdraw()</code> with specialized logic:</p> <pre><code>@Override\npublic boolean withdraw(double amount) {\n    if (isFrozen()) {\n        System.out.println(\"Cannot withdraw. Account #\" + getAccountId() + \" is frozen.\");\n        return false;\n    }\n\n    if (amount &lt;= 0) {\n        System.out.println(\"Withdrawal amount must be positive.\");\n        return false;\n    }\n\n    // Savings account specific check: cannot go below minimum balance\n    if (balance - amount &lt; minimumBalance) {\n        System.out.println(\"Cannot withdraw \u20ac\" + amount + \". Would violate minimum balance of \u20ac\" + minimumBalance + \". Current balance: \u20ac\" + balance);\n        return false;\n    }\n\n    // If all checks pass, use parent's withdraw logic\n    return super.withdraw(amount);\n}\n</code></pre> <p>The <code>@Override</code> annotation isn't required but is strongly recommended. It tells the compiler \"I intend to override a parent method.\" If you make a typo in the method name or get the parameters wrong, the compiler catches the error instead of creating a new unrelated method.</p> <p>Notice the method checks <code>balance - amount &lt; minimumBalance</code> before allowing the withdrawal. This enforcement exists only in <code>SavingsAccount</code>; standard accounts and checking accounts don't have this restriction. Each subclass customizes behavior by overriding methods.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#adding-subclass-specific-methods","title":"Adding Subclass-Specific Methods","text":"<p>Savings accounts have functionality that doesn't exist in the parent:</p> <p><pre><code>/**\n * Calculates interest earned on current balance.\n */\npublic double calculateInterest() {\n    return balance * interestRate;\n}\n\n/**\n * Adds calculated interest to the account.\n */\npublic double addInterest() {\n    double interest = calculateInterest();\n    if (interest &gt; 0) {\n        balance += interest;\n\n        // Record as a deposit transaction\n        Transaction transaction = new Transaction(\n                Transaction.TransactionType.DEPOSIT,\n                interest,\n                getAccountId(),\n                balance,\n                \"Interest credited at \" + (interestRate * 100) + \"%\"\n        );\n        transactionHistory.add(transaction);\n\n        System.out.println(\"Interest of \u20ac\" + String.format(\"%.2f\", interest) + \n                             \" added to Savings Account #\" + getAccountId());\n    }\n    return interest;\n}\n</code></pre> The subclass leverages parent functionality while adding new capabilities.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#overriding-getaccounttype-and-tostring","title":"Overriding getAccountType() and toString()","text":"<p>To complete the subclass, override identification methods:</p> <pre><code>@Override\npublic String getAccountType() {\n    return \"Savings Account\";\n}\n\n@Override\npublic String toString() {\n    return String.format(\"SavingsAccount{id=%d, balance=\u20ac%.2f, interestRate=%.2f%%, \" +\n                        \"minimumBalance=\u20ac%.2f, frozen=%b}\",\n                        getAccountId(), balance, interestRate * 100, \n                        minimumBalance, isFrozen());\n}\n</code></pre> <p>These methods replace the parent implementations, allowing polymorphic code to identify and display savings accounts correctly.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#creating-the-checkingaccount-subclass","title":"Creating the CheckingAccount Subclass","text":"<p><code>CheckingAccount</code> demonstrates different specialization: allowing overdrafts and charging fees. The structure mirrors <code>SavingsAccount</code> but the rules differ.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#specialized-fields-for-checking-accounts","title":"Specialized Fields for Checking Accounts","text":"<pre><code>private double overdraftLimit;   // How much can go below zero\nprivate double monthlyFee;       // Fee charged monthly\n\nprivate static final double DEFAULT_MONTHLY_FEE = 5.0;\n</code></pre> <p>Checking accounts allow negative balances within a limit, and they charge recurring fees. These fields support those rules.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#constructor-chaining","title":"Constructor Chaining","text":"<pre><code>public CheckingAccount(double initialBalance, double overdraftLimit) {\n    super(initialBalance);  // Initialize parent Account\n\n    if (overdraftLimit &lt; 0) {\n        System.out.println(\"Overdraft limit cannot be negative\");\n    }\n\n    this.overdraftLimit = overdraftLimit;\n    this.monthlyFee = DEFAULT_MONTHLY_FEE;\n}\n</code></pre> <p>Same pattern as <code>SavingsAccount</code>: call <code>super()</code> first to initialize inherited fields, then handle subclass-specific fields. An overloaded constructor allows custom monthly fees.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#overriding-withdraw-for-overdraft-support","title":"Overriding withdraw() for Overdraft Support","text":"<p>The key difference from standard accounts: checking accounts can go negative:</p> <pre><code>@Override\npublic boolean withdraw(double amount) {\n    if (isFrozen()) {\n        System.out.println(\"Cannot withdraw. Account #\" + getAccountId() + \" is frozen.\");\n        return false;\n    }\n\n    if (amount &lt;= 0) {\n        System.out.println(\"Withdrawal amount must be positive.\");\n        return false;\n    }\n\n    // Checking account specific check: can go negative up to overdraft limit\n    double availableBalance = balance + overdraftLimit;\n    if (amount &gt; availableBalance) {\n        System.out.println(\"Cannot withdraw \u20ac\" + amount + \". Exceeds available balance of \u20ac\" + String.format(\"%.2f\", availableBalance) + \n        \" (Balance: \u20ac\" + String.format(\"%.2f\", balance) + \n         \" + Overdraft: \u20ac\" + overdraftLimit + \")\");\n        return false;\n    }\n\n    // Perform withdrawal (may result in negative balance)\n    balance -= amount;\n\n    // Record transaction\n    Transaction transaction = new Transaction(\n            Transaction.TransactionType.WITHDRAW,\n            amount,\n            getAccountId(),\n            balance,\n            \"Withdrawal\" + (balance &lt; 0 ? \" (using overdraft)\" : \"\")\n    );\n    transactionHistory.add(transaction);\n\n    System.out.println(\"Withdrawn: \u20ac\" + amount + \" from Checking Account #\" + getAccountId());\n    if (balance &lt; 0) {\n        System.out.println(\"  (Account now in overdraft. Balance: \u20ac\" + String.format(\"%.2f\", balance) + \")\");\n    }\n\n    return true;\n}\n</code></pre> <p>The available balance includes the overdraft limit: <code>balance + overdraftLimit</code>. If your balance is \u20ac100 and overdraft limit is \u20ac500, you can withdraw up to \u20ac600. The balance can go to -\u20ac500.</p> <p>This demonstrates polymorphism's power: three account types, three different <code>withdraw()</code> implementations, but all share the same method signature. Code using accounts doesn't need to know which type it's working with\u2014it just calls <code>withdraw()</code> and gets the right behavior.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#fee-management","title":"Fee Management","text":"<p>Checking accounts need fee application:</p> <pre><code>/**\n * Applies monthly maintenance fee to the account.\n */\npublic void applyMonthlyFee() {\n    if (monthlyFee &gt; 0) {\n        balance -= monthlyFee;\n        recordTransaction(TransactionType.WITHDRAW, monthlyFee, \"Monthly maintenance fee\");\n        System.out.println(\"Monthly fee of \u20ac\" + monthlyFee + \" applied to Account #\" + \n                          getAccountId());\n    }\n}\n</code></pre> <p>This method directly modifies the balance and records a transaction. It demonstrates how subclasses access protected parent fields to implement specialized functionality.</p> <p>Utility methods provide checking account information:</p> <pre><code>public boolean isInOverdraft() {\n    return balance &lt; 0;\n}\n\npublic double getAvailableBalance() {\n    return balance + overdraftLimit;\n}\n</code></pre> <p>These methods exist only in <code>CheckingAccount</code>. Code working with generic <code>Account</code> references can't call them unless it uses type casting (covered later).</p>"},{"location":"02-core-oop/inheritance-polymorphism/#understanding-polymorphism","title":"Understanding Polymorphism","text":"<p>With subclasses defined, polymorphism becomes possible. This is where inheritance shows its real power: writing code that works with parent types but executes child behavior.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#parent-references-to-child-objects","title":"Parent References to Child Objects","text":"<p>Consider this code:</p> <pre><code>Account account1 = new SavingsAccount(1000.0, 0.03);\nAccount account2 = new CheckingAccount(500.0, 300.0);\nAccount account3 = new Account(750.0);\n</code></pre> <p>All three variables have type <code>Account</code>, but they reference different object types. This is legal because of the \"is-a\" relationship: a <code>SavingsAccount</code> is an <code>Account</code>, so you can store a <code>SavingsAccount</code> object in an <code>Account</code> variable.</p> <p>This is polymorphism: one interface (the parent type), multiple implementations (the child types). The variable type is <code>Account</code>, but the actual object can be any Account subclass.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#method-dispatch-at-runtime","title":"Method Dispatch at Runtime","text":"<p>When you call methods on polymorphic references, Java determines which version to execute at runtime based on the actual object type:</p> <pre><code>account1.withdraw(100.0);  // Calls SavingsAccount.withdraw()\naccount2.withdraw(100.0);  // Calls CheckingAccount.withdraw()\naccount3.withdraw(100.0);  // Calls Account.withdraw()\n</code></pre> <p>Even though all three variables have type <code>Account</code>, each calls its own <code>withdraw()</code> implementation. This is dynamic dispatch: the method called depends on the runtime object type, not the compile-time variable type.</p> <p>This enables powerful abstractions. The Bank can store all accounts in one <code>ArrayList&lt;Account&gt;</code>, and when it calls methods, each account behaves according to its actual type without the Bank needing conditional logic:</p> <pre><code>// Bank doesn't need to know account types\nfor (Account account : customer.getAccounts()) {\n    account.withdraw(50.0);  // Right behavior for each type\n}\n</code></pre>"},{"location":"02-core-oop/inheritance-polymorphism/#the-limits-of-polymorphic-references","title":"The Limits of Polymorphic References","text":"<p>While polymorphic references enable flexible code, they have a restriction: you can only call methods defined in the reference type. Consider:</p> <pre><code>Account account = new SavingsAccount(1000.0, 0.03);\n\naccount.deposit(100.0);        // OK - defined in Account\naccount.withdraw(50.0);        // OK - defined in Account (calls SavingsAccount version)\naccount.getBalance();          // OK - defined in Account\n\naccount.addInterest();         // COMPILER ERROR - not defined in Account\n</code></pre> <p>The compiler sees the variable as type <code>Account</code>, so it only allows methods declared in <code>Account</code>. Even though the actual object is a <code>SavingsAccount</code> with an <code>addInterest()</code> method, you can't call it through an <code>Account</code> reference.</p> <p>This makes sense from the compiler's perspective: if <code>account</code> could reference any Account subclass, and not all subclasses have <code>addInterest()</code>, allowing the call would be unsafe. What if <code>account</code> actually referenced a <code>CheckingAccount</code> at runtime?</p>"},{"location":"02-core-oop/inheritance-polymorphism/#type-checking-with-instanceof","title":"Type Checking with instanceof","text":"<p>To safely call subclass-specific methods, first check the actual type using <code>instanceof</code>:</p> <pre><code>Account account = new SavingsAccount(1000.0, 0.03);\n\nif (account instanceof SavingsAccount) {\n    SavingsAccount savingsAccount = (SavingsAccount) account;\n    savingsAccount.addInterest();  // Safe - we know it's a SavingsAccount\n}\n</code></pre> <p>The <code>instanceof</code> operator returns <code>true</code> if the object is of the specified type (or a subclass of that type). After confirming the type, you cast the reference to the specific type, making subclass methods accessible.</p> <p>Java 16+ introduced pattern matching that combines the check and cast:</p> <pre><code>if (account instanceof SavingsAccount sa) {\n    sa.addInterest();  // 'sa' is automatically cast\n}\n</code></pre> <p>This is cleaner and eliminates the explicit cast. The variable <code>sa</code> is automatically the correct type within the if block.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#why-this-matters","title":"Why This Matters","text":"<p>Polymorphism enables:</p> <ul> <li>Flexible collections: Store different account types in one list</li> <li>Extensible code: Add new account types without changing existing code</li> <li>Interface-based programming: Work with abstractions (Account) instead of concrete types</li> <li>Runtime behavior selection: The right method executes based on actual object type</li> </ul> <p>This is fundamental to OOP design. Systems built with polymorphism adapt to new requirements more easily than systems built with conditionals and type checking.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#extending-the-bank-class","title":"Extending the Bank Class","text":"<p>The Bank class needs updates to support multiple account types. The changes demonstrate polymorphism in practice: storing different account types together while providing type-specific operations.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#opening-different-account-types","title":"Opening Different Account Types","text":"<p>Version 3's Bank couldn't distinguish account types. Version 4 adds methods to create specific account types:</p> <pre><code>/**\n * Opens a new savings account for a customer.\n */\npublic SavingsAccount openSavingsAccount(int customerId, double initialBalance, \n                                         double interestRate) {\n    Customer customer = findCustomer(customerId);\n    if (customer == null) {\n        System.out.println(\"Customer with ID \" + customerId + \" not found.\");\n        return null;\n    }\n\n    SavingsAccount account = new SavingsAccount(initialBalance, interestRate);\n    customer.addAccount(account);\n    System.out.println(\"Savings account #\" + account.getAccountId() + \n                      \" opened for \" + customer.getName());\n    return account;\n}\n\n/**\n * Opens a new checking account for a customer.\n */\npublic CheckingAccount openCheckingAccount(int customerId, double initialBalance, \n                                          double overdraftLimit) {\n    Customer customer = findCustomer(customerId);\n    if (customer == null) {\n        System.out.println(\"Customer with ID \" + customerId + \" not found.\");\n        return null;\n    }\n\n    CheckingAccount account = new CheckingAccount(initialBalance, overdraftLimit);\n    customer.addAccount(account);\n    System.out.println(\"Checking account #\" + account.getAccountId() + \n                      \" opened for \" + customer.getName());\n    return account;\n}\n</code></pre> <p>These methods return specific types (<code>SavingsAccount</code>, <code>CheckingAccount</code>) so callers can immediately use type-specific methods. But internally, <code>Customer.addAccount()</code> stores them in <code>ArrayList&lt;Account&gt;</code>, demonstrating polymorphic storage.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#bank-wide-operations-using-instanceof","title":"Bank-Wide Operations Using instanceof","text":"<p>Some operations apply only to specific account types. The Bank needs to iterate through all accounts and process only certain types:</p> <pre><code>/**\n * Applies interest to all savings accounts in the bank.\n */\npublic void applyInterestToAllSavings() {\n    int count = 0;\n    for (Customer customer : customers) {\n        for (Account account : customer.getAccounts()) {\n            if (account instanceof SavingsAccount) {\n                SavingsAccount sa = (SavingsAccount) account;\n                sa.addInterest();\n                count++;\n            }\n        }\n    }\n    System.out.println(\"Interest applied to \" + count + \" savings accounts.\");\n}\n</code></pre> <p>This method demonstrates polymorphic iteration with type-specific operations. The inner loop iterates over <code>Account</code> references (polymorphic collection), uses <code>instanceof</code> to identify savings accounts, casts to the specific type, and calls the subclass-specific <code>addInterest()</code> method.</p> <p>Monthly fee processing follows the same pattern:</p> <pre><code>/**\n * Applies monthly fees to all checking accounts in the bank.\n */\npublic void applyMonthlyFeesToAllChecking() {\n    int count = 0;\n    for (Customer customer : customers) {\n        for (Account account : customer.getAccounts()) {\n            if (account instanceof CheckingAccount) {\n                CheckingAccount ca = (CheckingAccount) account;\n                ca.applyMonthlyFee();\n                count++;\n            }\n        }\n    }\n    System.out.println(\"Monthly fees applied to \" + count + \" checking accounts.\");\n}\n</code></pre>"},{"location":"02-core-oop/inheritance-polymorphism/#improved-bank-reporting","title":"Improved Bank Reporting","text":"<p>The <code>generateBankReport()</code> method now provides type-specific statistics:</p> <pre><code>public void generateBankReport() {\n    System.out.println(\"\\n\" + \"=\".repeat(60));\n    System.out.println(bankName + \" - Bank Report\");\n    System.out.println(\"=\".repeat(60));\n\n    int totalAccounts = 0;\n    int savingsCount = 0;\n    int checkingCount = 0;\n    int standardCount = 0;\n    double totalBalance = 0.0;\n\n    for (Customer customer : customers) {\n        List&lt;Account&gt; accounts = customer.getAccounts();\n        totalAccounts += accounts.size();\n\n        for (Account account : accounts) {\n            totalBalance += account.getBalance();\n\n            // Count by type using instanceof\n            if (account instanceof SavingsAccount) {\n                savingsCount++;\n            } else if (account instanceof CheckingAccount) {\n                checkingCount++;\n            } else {\n                standardCount++;\n            }\n        }\n    }\n\n    System.out.println(\"Total Customers: \" + customers.size());\n    System.out.println(\"Total Accounts: \" + totalAccounts);\n    System.out.println(\"  - Savings Accounts: \" + savingsCount);\n    System.out.println(\"  - Checking Accounts: \" + checkingCount);\n    System.out.println(\"  - Standard Accounts: \" + standardCount);\n    System.out.println(\"Total Bank Balance: \u20ac\" + String.format(\"%.2f\", totalBalance));\n    System.out.println(\"=\".repeat(60));\n}\n</code></pre> <p>The method uses <code>instanceof</code> to categorize accounts by type. This demonstrates practical polymorphism: iterate with parent type references, use <code>instanceof</code> when type-specific logic is needed.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#putting-it-all-together","title":"Putting It All Together","text":"<p>With the inheritance hierarchy complete, here's how the system works in practice. This demonstrates the interplay between polymorphism, method overriding, and type-specific operations.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#creating-polymorphic-accounts","title":"Creating Polymorphic Accounts","text":"<pre><code>public class BankSystemMain {\n    public static void main(String[] args) {\n        Bank turingBank = new Bank(\"Turing National Bank\");\n\n        // Create customers\n        Customer ada = new Customer(1815, \"Ada Lovelace\", 36, \n                                   \"10 St. James Square, London\");\n        Customer alan = new Customer(1912, \"Alan Turing\", 41, \n                                    \"Sherborne School, Dorset\");\n\n        turingBank.addCustomer(ada);\n        turingBank.addCustomer(alan);\n\n        // Open different account types\n        SavingsAccount adaSavings = turingBank.openSavingsAccount(1815, 5000.0, 0.03);\n        CheckingAccount adaChecking = turingBank.openCheckingAccount(1815, 2000.0, 500.0);\n\n        SavingsAccount alanSavings = turingBank.openSavingsAccount(1912, 3000.0, 0.025);\n        CheckingAccount alanChecking = turingBank.openCheckingAccount(1912, 1500.0, 300.0);\n    }\n}\n</code></pre> <p>Output: <pre><code>Customer Ada Lovelace (ID: 1815) added to Turing National Bank\nCustomer Alan Turing (ID: 1912) added to Turing National Bank\nSavings account #1001 opened for Ada Lovelace\nChecking account #1002 opened for Ada Lovelace\nSavings account #1003 opened for Alan Turing\nChecking account #1004 opened for Alan Turing\n</code></pre></p>"},{"location":"02-core-oop/inheritance-polymorphism/#demonstrating-method-overriding","title":"Demonstrating Method Overriding","text":"<p>Each account type behaves differently:</p> <pre><code>// Savings account enforces minimum balance\nadaSavings.withdraw(4950.0);  // Denied - would violate \u20ac100 minimum\n\n// Checking account allows overdraft\nadaChecking.withdraw(2300.0);  // Allowed - goes to -\u20ac300 (within -\u20ac500 limit)\n\n// Standard behavior\nadaSavings.deposit(1000.0);  // Works for all types\n</code></pre> <p>Output: <pre><code>Withdrawal denied. Would violate minimum balance of \u20ac100.0\nWithdrew: \u20ac2300.0 from Checking Account #1002 (now in overdraft: \u20ac-300.0)\nDeposited: \u20ac1000.0 to Account #1001\n</code></pre></p> <p>The same method names (<code>withdraw</code>, <code>deposit</code>) execute different logic based on actual object type.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#polymorphic-collections-in-action","title":"Polymorphic Collections in Action","text":"<p>Customer stores all account types in one list:</p> <pre><code>// Inside Customer class\nprivate ArrayList&lt;Account&gt; accounts;  // Holds any Account subclass\n\n// Later\nfor (Account account : ada.getAccounts()) {\n    System.out.println(account.getAccountType() + \" #\" + account.getAccountId() + \n                      \": \u20ac\" + account.getBalance());\n}\n</code></pre> <p>Output: <pre><code>Savings Account #1001: \u20ac6000.0\nChecking Account #1002: \u20ac-300.0\n</code></pre></p> <p>Each account reports its correct type even though they're all stored as <code>Account</code> references.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#type-specific-operations","title":"Type-Specific Operations","text":"<p>Apply interest only to savings accounts:</p> <pre><code>turingBank.applyInterestToAllSavings();\n</code></pre> <p>Output: <pre><code>Interest added: \u20ac180.00 to Account #1001\nInterest added: \u20ac75.00 to Account #1003\nInterest applied to 2 savings accounts.\n</code></pre></p> <p>Checking accounts aren't affected\u2014the Bank identifies savings accounts using <code>instanceof</code> and applies interest only to them.</p> <p>Apply fees only to checking accounts:</p> <pre><code>turingBank.applyMonthlyFeesToAllChecking();\n</code></pre> <p>Output: <pre><code>Monthly fee of \u20ac5.0 applied to Account #1002\nMonthly fee of \u20ac5.0 applied to Account #1004\nMonthly fees applied to 2 checking accounts.\n</code></pre></p>"},{"location":"02-core-oop/inheritance-polymorphism/#working-with-specific-types","title":"Working with Specific Types","text":"<p>When you need subclass-specific functionality:</p> <pre><code>// Get reference as specific type\nSavingsAccount savings = turingBank.openSavingsAccount(1815, 10000.0, 0.04);\n\n// Can call subclass methods directly\ndouble interest = savings.calculateInterest();\nSystem.out.println(\"Interest to be earned: \u20ac\" + interest);\n\nsavings.addInterest();\n\n// Or use instanceof and casting\nAccount account = ada.findAccount(1001);\nif (account instanceof SavingsAccount) {\n    SavingsAccount sa = (SavingsAccount) account;\n    System.out.println(\"Interest rate: \" + (sa.getInterestRate() * 100) + \"%\");\n}\n</code></pre>"},{"location":"02-core-oop/inheritance-polymorphism/#bank-report-with-type-statistics","title":"Bank Report with Type Statistics","text":"<pre><code>turingBank.generateBankReport();\n</code></pre> <p>Output: <pre><code>============================================================\nTuring National Bank - Bank Report\n============================================================\nTotal Customers: 2\nTotal Accounts: 4\n  - Savings Accounts: 2\n  - Checking Accounts: 2\n  - Standard Accounts: 0\nTotal Bank Balance: \u20ac15775.00\n============================================================\n</code></pre></p> <p>The Bank processes all accounts polymorphically while tracking type-specific statistics.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#summary","title":"Summary","text":"<p>You've extended the banking system with inheritance and polymorphism, enabling specialized account types while maintaining clean, maintainable code. The hierarchy creates flexibility impossible with a single Account class.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#key-concepts-mastered","title":"Key Concepts Mastered","text":""},{"location":"02-core-oop/inheritance-polymorphism/#inheritance-and-the-is-a-relationship","title":"Inheritance and the \"is-a\" relationship","text":"<p>Subclasses extend parent classes, inheriting all public and protected members. SavingsAccount is-a Account, CheckingAccount is-a Account. Use inheritance when objects share common behavior but need specialized rules.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#the-protected-access-modifier_1","title":"The protected access modifier","text":"<p>Protected fields and methods are visible to subclasses but hidden from external code. This enables subclasses to access parent state (like <code>balance</code>) while maintaining encapsulation from external manipulation.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#constructor-chaining-with-super_1","title":"Constructor chaining with super()","text":"<p>Subclass constructors must call a parent constructor using <code>super()</code> as the first statement. This ensures proper initialization of inherited fields before subclass-specific initialization.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#method-overriding","title":"Method overriding","text":"<p>Subclasses can replace parent method implementations to customize behavior. Use <code>@Override</code> to catch errors. Overridden methods must have identical signatures to the parent method they replace.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#polymorphism","title":"Polymorphism","text":"<p>Parent type references can hold child type objects. Method calls execute the actual object's version (dynamic dispatch), not the reference type's version. This enables flexible collections and extensible designs.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#instanceof-and-type-casting","title":"instanceof and type casting","text":"<p>Check actual object types with <code>instanceof</code> before calling subclass-specific methods. Cast references to access subclass functionality. Pattern matching (Java 16+) combines the check and cast.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#polymorphic-collections","title":"Polymorphic collections","text":"<p>Store different types in one collection using the parent type: <code>ArrayList&lt;Account&gt;</code> holds SavingsAccount, CheckingAccount, and Account objects. Iterate once, get specialized behavior automatically.</p>"},{"location":"02-core-oop/inheritance-polymorphism/#design-benefits","title":"Design Benefits","text":"<p>The inheritance hierarchy provides:</p> <ul> <li>Code reuse: Common functionality (deposits, transactions, freezing) exists once in Account</li> <li>Extensibility: Add new account types (BusinessAccount, StudentAccount) without changing existing code</li> <li>Maintainability: Fix bugs once in the parent; all subclasses benefit</li> <li>Flexibility: Bank operations work with any account type without conditionals</li> <li>Type safety: Compiler ensures only valid operations occur on each type</li> </ul>"},{"location":"02-core-oop/inheritance-polymorphism/#when-to-use-inheritance","title":"When to Use Inheritance","text":"<p>Inheritance fits when: - Objects have genuine \"is-a\" relationships (not just code reuse) - Subclasses share significant common behavior - You need polymorphic behavior (treating different types uniformly) - The hierarchy models real-world categories</p> <p>Inheritance doesn't fit when: - The relationship is \"has-a\" (use composition) - Subclasses would override most parent methods (weak common behavior) - You're inheriting just to reuse code (prefer composition)</p>"},{"location":"02-core-oop/inheritance-polymorphism/#complete-code","title":"Complete Code","text":"<p>Find the complete working code:</p> <ul> <li>v3_thinking_in_objects - Version 3 with Bank, Transaction, and SRP</li> <li>v4_inheritance_polymorphism - Version 4 with Account hierarchy</li> </ul> <p>The Account hierarchy creates a foundation for future extensions. Next, you'll explore abstract classes and interfaces: defining contracts that subclasses must fulfill, creating pure abstractions without implementation, and designing systems around interfaces instead of concrete types. The inheritance structure makes these advanced concepts natural progressions.</p>"},{"location":"03-io-exceptions/","title":"File and Exception Handling Overview","text":"<p>Build robust applications that handle errors gracefully and work with external data. Learn to manage exceptions and interact with the file system using streams and modern I/O techniques.</p>"},{"location":"03-io-exceptions/#exception-handling","title":"Exception Handling","text":"<p>Write bulletproof code</p> <p>Master Java's exception handling system to create applications that recover from errors instead of crashing. Learn try-catch blocks, custom exceptions, and best practices for defensive programming.</p> <p>You'll learn: Try-catch-finally blocks, checked vs unchecked exceptions, throwing custom exceptions, and error handling strategies</p>"},{"location":"03-io-exceptions/#files-streams","title":"Files &amp; Streams","text":"<p>Connect to the outside world</p> <p>Work with files and directories using Java's I/O system. Understand byte streams, character streams, buffered I/O, and modern file operations for reading and writing data efficiently.</p> <p>You'll learn: FileInputStream/FileOutputStream, FileReader/FileWriter, buffered streams, and when to use each approach for different file operations</p> <p>Start here: Begin with Exception Handling to understand error management, then move to Files &amp; Streams to work with external data. Complete the exercises after both topics\u2014these skills are essential for real-world applications that must handle unexpected situations and persistent data.</p>"},{"location":"03-io-exceptions/exception-handling.mdfiles-streams/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"03-io-exceptions/exercises/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"03-io-exceptions/files-streams/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"04-modern-java/","title":"Modern Java Overview","text":"<p>Learn the newer Java features that make your code cleaner and more powerful. Use generics for type safety, lambdas and streams for better data processing, and JavaFX to create desktop applications with visual interfaces.</p>"},{"location":"04-modern-java/#generics","title":"Generics","text":"<p>Type-safe, reusable code</p> <p>Learn Java's generics to write code that works with different types while catching errors at compile time. Create classes and methods that can handle multiple data types safely without casting or runtime errors.</p> <p>You'll learn: Generic classes and methods, type parameters, wildcards, and building components that work with different data types safely</p>"},{"location":"04-modern-java/#lambdas-streams","title":"Lambdas &amp; Streams","text":"<p>Functional programming in Java</p> <p>Use lambda expressions and the Stream API to process collections more efficiently. Replace long loops with short, clear operations for filtering, mapping, and reducing data in your programs.</p> <p>You'll learn: Lambda syntax, functional interfaces, stream operations like map/filter/reduce, method references, and processing data collections effectively</p>"},{"location":"04-modern-java/#javafx-gui","title":"JavaFX &amp; GUI","text":"<p>Build desktop applications</p> <p>Create desktop programs with graphical interfaces using JavaFX. Build interactive applications with buttons, text fields, layouts, and event handling for user-friendly software.</p> <p>You'll learn: JavaFX components, scene structure, event handling, layouts, styling with CSS, and building complete desktop applications</p> <p>Start here: Begin with Generics to understand type safety, then learn Lambdas &amp; Streams for data processing. Finish with JavaFX &amp; GUI to build visual applications. Complete the exercises after each topic\u2014these features will make your Java code more effective and modern.</p>"},{"location":"04-modern-java/exercises/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"04-modern-java/generics/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"04-modern-java/javafx-gui/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"04-modern-java/lambdas-streams/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"projects/","title":"Projects Overview","text":"<p>Apply your Java OOP knowledge through progressive building projects. Each sprint focuses on specific concepts, building from simple applications to complex systems that showcase your programming skills.</p>"},{"location":"projects/#sprint-1-early-concepts","title":"Sprint 1 - Early Concepts","text":"<p>Build your first object-oriented application</p> <p>Create a simple program using classes, objects, and basic collections. Focus on proper class design, object creation, and managing data with arrays or ArrayList. This sprint reinforces foundation concepts through practical coding.</p> <p>You'll build: A basic application like a student management system, library catalog, or inventory tracker using fundamental OOP concepts</p>"},{"location":"projects/#sprint-2-oop-principles","title":"Sprint 2 - OOP Principles","text":"<p>Design with inheritance and polymorphism</p> <p>Expand your application using inheritance hierarchies, method overriding, and polymorphic behavior. Implement proper encapsulation with access modifiers and create abstract classes or interfaces for flexible design.</p> <p>You'll build: An extended version of your Sprint 1 project with class hierarchies, specialized subclasses, and polymorphic method calls</p>"},{"location":"projects/#sprint-3-advanced-integration","title":"Sprint 3 - Advanced Integration","text":"<p>Handle real-world challenges</p> <p>Add robust error handling with exceptions and persistent data storage using file I/O. Integrate multiple advanced concepts to create a complete, professional application that handles unexpected situations gracefully.</p> <p>You'll build: A full-featured application with exception handling, file persistence, and advanced OOP design patterns</p>"},{"location":"projects/#final-project","title":"Final Project","text":"<p>Showcase your mastery</p> <p>Design and implement a comprehensive Java application that demonstrates all course concepts. Include modern Java features like generics, lambdas, and optionally a graphical interface. This capstone project shows your complete OOP programming skills.</p> <p>You'll build: A substantial application of your choice that incorporates the full range of Java OOP techniques learned throughout the course</p> <p>Start here: Begin Sprint 1 after completing the Foundations section. Work through each sprint in order, as they build upon previous work. Take time to plan your application design before coding\u2014good planning makes implementation smoother and more successful.</p>"},{"location":"projects/final_project/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"projects/sprint-1/","title":"Sprint 1 - Early Concepts","text":""},{"location":"projects/sprint-1/#goal","title":"Goal","text":"<p>Turn a real-world use case into a minimal, working OOP skeleton that models key entities and relationships using classes, objects, and collections, supported by a class diagram and short documentation.</p> <p>Emphasize Foundations: Fundamentals of OOP, Classes and Objects, Arrays/Lists, and Thinking in Objects, ensuring clear encapsulation and basic interactions between objects.</p>"},{"location":"projects/sprint-1/#key-elements","title":"Key elements","text":"Element Details Topics covered Fundamentals of OOP, Classes &amp; Objects, Arrays/Lists, Thinking in Objects. Teams 2\u20134 students per team; team must remain the same for all sprints. Points Semester project: 30 points; Sprint 1: 10 points. Deadline November 4 (end of day). Submission One team submission: repository link (or ZIP) containing requirements brief, class diagram (PNG/PDF), and the code developed. Point distribution Project defense 3 pts, Class Diagram 2 pts, Core Classes 4 pts, Documentation 1 pt."},{"location":"projects/sprint-1/#what-to-deliver","title":"What to deliver","text":"<p>You must deliver one zipped folder per group that contains all Sprint 1 materials. The zipped folder must include</p> <ul> <li>Two-page document: include the project goal, a concise list of key expected functionalities, and a requirements brief mapping core user actions to initial entities and relationships for Sprint 1 scope, with an embedded UML class diagram showing classes, key attributes, and associations/multiplicities</li> <li>Source code: implement 2\u20133 core classes with constructors, fields, and methods that collaborate using at least one collection (for example, a List) to demonstrate encapsulation and basic object interactions reflective of the Foundations topics.</li> </ul>"},{"location":"projects/sprint-1/#project-ideas","title":"Project ideas","text":"<p>Choose a project your team finds interesting and useful, and make sure it directly uses the key topics we are focusing on right now: OOP, Collections, and Thinking in Objects.</p> <p>Keep Sprint 1 small and focused: define a few real-world entities as classes, show how they relate, and use lists or other collections to support simple actions and data flows.</p> <p>Write clean, readable code and include a simple class diagram; advanced features can wait for later sprints once your foundation is solid and easy to extend. Below are some suggested ideas to get you started.</p>"},{"location":"projects/sprint-1/#university-management-system","title":"University Management System:","text":"<p>Start with Students, Courses, Instructors, and Enrollments so you can add students to courses and list who is enrolled where. Keep it simple: create the core classes and basic methods to enroll and view enrollments, using a list to store relationships. Later sprints can add grading, schedules, or departments after the basics work well.</p>"},{"location":"projects/sprint-1/#library-management-system","title":"Library Management System","text":"<p>Start with Books, Members, and Loans so you can check out and return books and see what is available. Keep it simple: create the core classes and a list of current loans to track availability and due dates at a basic level. Later sprints can add reservations, fines, or reports once the core flow is stable.</p>"},{"location":"projects/sprint-1/#attendance-management-system","title":"Attendance Management System","text":"<p>Start with Users, Sessions, and AttendanceRecords so you can mark attendance and list who attended which session. Keep it simple: create the core classes and use a list or map to store records, with a minimal difference between admin, faculty, and student roles for now. Later sprints can add summaries and filters by date or course after the basics work</p>"},{"location":"projects/sprint-2/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"projects/sprint-3/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"},{"location":"resources/","title":"Under Construction","text":"<p>This page is still under construction. </p> <p>If you feel like a break, grab a coffee and check back later. Building quality takes a bit of patience!</p> <p></p>"}]}